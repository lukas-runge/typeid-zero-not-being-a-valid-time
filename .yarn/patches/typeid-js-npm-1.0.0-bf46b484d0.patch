diff --git a/dist/index.js b/dist/index.js
index 044030b88cf125b056ae9062140267f95cd87485..59a27669d4235ccacb5ba4da43bfd3786b9b5fdd 100644
--- a/dist/index.js
+++ b/dist/index.js
@@ -1,9 +1,10 @@
 "use strict";
+var __create = Object.create;
 var __defProp = Object.defineProperty;
 var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
 var __getOwnPropNames = Object.getOwnPropertyNames;
+var __getProtoOf = Object.getPrototypeOf;
 var __hasOwnProp = Object.prototype.hasOwnProperty;
-var __pow = Math.pow;
 var __export = (target, all) => {
   for (var name in all)
     __defProp(target, name, { get: all[name], enumerable: true });
@@ -16,6 +17,14 @@ var __copyProps = (to, from, except, desc) => {
   }
   return to;
 };
+var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
+  // If the importer is in node compatibility mode or this is not an ESM
+  // file that has been converted to a CommonJS file using a Babel-
+  // compatible transform (i.e. "__esModule" has not been set), then set
+  // "default" to the CommonJS "module.exports" for node compatibility.
+  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
+  mod
+));
 var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
 
 // src/index.ts
@@ -35,322 +44,110 @@ __export(src_exports, {
 });
 module.exports = __toCommonJS(src_exports);
 
-// node_modules/.pnpm/uuidv7@0.6.2/node_modules/uuidv7/dist/index.js
-var DIGITS = "0123456789abcdef";
-var UUID = class {
-  /** @param bytes - The 16-byte byte array representation. */
-  constructor(bytes) {
-    this.bytes = bytes;
-  }
-  /**
-   * Creates an object from the internal representation, a 16-byte byte array
-   * containing the binary UUID representation in the big-endian byte order.
-   *
-   * This method does NOT shallow-copy the argument, and thus the created object
-   * holds the reference to the underlying buffer.
-   *
-   * @throws TypeError if the length of the argument is not 16.
-   */
-  static ofInner(bytes) {
-    if (bytes.length !== 16) {
-      throw new TypeError("not 128-bit length");
-    } else {
-      return new UUID(bytes);
-    }
-  }
-  /**
-   * Builds a byte array from UUIDv7 field values.
-   *
-   * @param unixTsMs - A 48-bit `unix_ts_ms` field value.
-   * @param randA - A 12-bit `rand_a` field value.
-   * @param randBHi - The higher 30 bits of 62-bit `rand_b` field value.
-   * @param randBLo - The lower 32 bits of 62-bit `rand_b` field value.
-   * @throws RangeError if any field value is out of the specified range.
-   */
-  static fromFieldsV7(unixTsMs, randA, randBHi, randBLo) {
-    if (!Number.isInteger(unixTsMs) || !Number.isInteger(randA) || !Number.isInteger(randBHi) || !Number.isInteger(randBLo) || unixTsMs < 0 || randA < 0 || randBHi < 0 || randBLo < 0 || unixTsMs > 281474976710655 || randA > 4095 || randBHi > 1073741823 || randBLo > 4294967295) {
-      throw new RangeError("invalid field value");
-    }
-    const bytes = new Uint8Array(16);
-    bytes[0] = unixTsMs / __pow(2, 40);
-    bytes[1] = unixTsMs / __pow(2, 32);
-    bytes[2] = unixTsMs / __pow(2, 24);
-    bytes[3] = unixTsMs / __pow(2, 16);
-    bytes[4] = unixTsMs / __pow(2, 8);
-    bytes[5] = unixTsMs;
-    bytes[6] = 112 | randA >>> 8;
-    bytes[7] = randA;
-    bytes[8] = 128 | randBHi >>> 24;
-    bytes[9] = randBHi >>> 16;
-    bytes[10] = randBHi >>> 8;
-    bytes[11] = randBHi;
-    bytes[12] = randBLo >>> 24;
-    bytes[13] = randBLo >>> 16;
-    bytes[14] = randBLo >>> 8;
-    bytes[15] = randBLo;
-    return new UUID(bytes);
-  }
-  /**
-   * Builds a byte array from a string representation.
-   *
-   * This method accepts the following formats:
-   *
-   * - 32-digit hexadecimal format without hyphens: `0189dcd553117d408db09496a2eef37b`
-   * - 8-4-4-4-12 hyphenated format: `0189dcd5-5311-7d40-8db0-9496a2eef37b`
-   * - Hyphenated format with surrounding braces: `{0189dcd5-5311-7d40-8db0-9496a2eef37b}`
-   * - RFC 4122 URN format: `urn:uuid:0189dcd5-5311-7d40-8db0-9496a2eef37b`
-   *
-   * Leading and trailing whitespaces represents an error.
-   *
-   * @throws SyntaxError if the argument could not parse as a valid UUID string.
-   */
-  static parse(uuid) {
-    var _a, _b, _c, _d;
-    let hex = void 0;
-    switch (uuid.length) {
-      case 32:
-        hex = (_a = /^[0-9a-f]{32}$/i.exec(uuid)) === null || _a === void 0 ? void 0 : _a[0];
-        break;
-      case 36:
-        hex = (_b = /^([0-9a-f]{8})-([0-9a-f]{4})-([0-9a-f]{4})-([0-9a-f]{4})-([0-9a-f]{12})$/i.exec(uuid)) === null || _b === void 0 ? void 0 : _b.slice(1, 6).join("");
-        break;
-      case 38:
-        hex = (_c = /^\{([0-9a-f]{8})-([0-9a-f]{4})-([0-9a-f]{4})-([0-9a-f]{4})-([0-9a-f]{12})\}$/i.exec(uuid)) === null || _c === void 0 ? void 0 : _c.slice(1, 6).join("");
-        break;
-      case 45:
-        hex = (_d = /^urn:uuid:([0-9a-f]{8})-([0-9a-f]{4})-([0-9a-f]{4})-([0-9a-f]{4})-([0-9a-f]{12})$/i.exec(uuid)) === null || _d === void 0 ? void 0 : _d.slice(1, 6).join("");
-        break;
-      default:
-        break;
-    }
-    if (hex) {
-      const inner = new Uint8Array(16);
-      for (let i = 0; i < 16; i += 4) {
-        const n = parseInt(hex.substring(2 * i, 2 * i + 8), 16);
-        inner[i + 0] = n >>> 24;
-        inner[i + 1] = n >>> 16;
-        inner[i + 2] = n >>> 8;
-        inner[i + 3] = n;
-      }
-      return new UUID(inner);
-    } else {
-      throw new SyntaxError("could not parse UUID string");
-    }
-  }
-  /**
-   * @returns The 8-4-4-4-12 canonical hexadecimal string representation
-   * (`0189dcd5-5311-7d40-8db0-9496a2eef37b`).
-   */
-  toString() {
-    let text = "";
-    for (let i = 0; i < this.bytes.length; i++) {
-      text += DIGITS.charAt(this.bytes[i] >>> 4);
-      text += DIGITS.charAt(this.bytes[i] & 15);
-      if (i === 3 || i === 5 || i === 7 || i === 9) {
-        text += "-";
-      }
-    }
-    return text;
-  }
-  /**
-   * @returns The 32-digit hexadecimal representation without hyphens
-   * (`0189dcd553117d408db09496a2eef37b`).
-   */
-  toHex() {
-    let text = "";
-    for (let i = 0; i < this.bytes.length; i++) {
-      text += DIGITS.charAt(this.bytes[i] >>> 4);
-      text += DIGITS.charAt(this.bytes[i] & 15);
-    }
-    return text;
-  }
-  /** @returns The 8-4-4-4-12 canonical hexadecimal string representation. */
-  toJSON() {
-    return this.toString();
-  }
-  /**
-   * Reports the variant field value of the UUID or, if appropriate, "NIL" or
-   * "MAX".
-   *
-   * For convenience, this method reports "NIL" or "MAX" if `this` represents
-   * the Nil or Max UUID, although the Nil and Max UUIDs are technically
-   * subsumed under the variants `0b0` and `0b111`, respectively.
-   */
-  getVariant() {
-    const n = this.bytes[8] >>> 4;
-    if (n < 0) {
-      throw new Error("unreachable");
-    } else if (n <= 7) {
-      return this.bytes.every((e) => e === 0) ? "NIL" : "VAR_0";
-    } else if (n <= 11) {
-      return "VAR_10";
-    } else if (n <= 13) {
-      return "VAR_110";
-    } else if (n <= 15) {
-      return this.bytes.every((e) => e === 255) ? "MAX" : "VAR_RESERVED";
-    } else {
-      throw new Error("unreachable");
-    }
+// node_modules/.pnpm/uuid@10.0.0/node_modules/uuid/dist/esm-node/regex.js
+var regex_default = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-8][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000|ffffffff-ffff-ffff-ffff-ffffffffffff)$/i;
+
+// node_modules/.pnpm/uuid@10.0.0/node_modules/uuid/dist/esm-node/validate.js
+function validate(uuid) {
+  return typeof uuid === "string" && regex_default.test(uuid);
+}
+var validate_default = validate;
+
+// node_modules/.pnpm/uuid@10.0.0/node_modules/uuid/dist/esm-node/stringify.js
+var byteToHex = [];
+for (let i = 0; i < 256; ++i) {
+  byteToHex.push((i + 256).toString(16).slice(1));
+}
+function unsafeStringify(arr, offset = 0) {
+  return (byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + "-" + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + "-" + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + "-" + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + "-" + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]]).toLowerCase();
+}
+function stringify(arr, offset = 0) {
+  const uuid = unsafeStringify(arr, offset);
+  if (!validate_default(uuid)) {
+    throw TypeError("Stringified UUID is invalid");
   }
-  /**
-   * Returns the version field value of the UUID or `undefined` if the UUID does
-   * not have the variant field value of `0b10`.
-   */
-  getVersion() {
-    return this.getVariant() === "VAR_10" ? this.bytes[6] >>> 4 : void 0;
-  }
-  /** Creates an object from `this`. */
-  clone() {
-    return new UUID(this.bytes.slice(0));
-  }
-  /** Returns true if `this` is equivalent to `other`. */
-  equals(other) {
-    return this.compareTo(other) === 0;
-  }
-  /**
-   * Returns a negative integer, zero, or positive integer if `this` is less
-   * than, equal to, or greater than `other`, respectively.
-   */
-  compareTo(other) {
-    for (let i = 0; i < 16; i++) {
-      const diff = this.bytes[i] - other.bytes[i];
-      if (diff !== 0) {
-        return Math.sign(diff);
-      }
+  return uuid;
+}
+var stringify_default = stringify;
+
+// node_modules/.pnpm/uuid@10.0.0/node_modules/uuid/dist/esm-node/rng.js
+var import_node_crypto = __toESM(require("crypto"));
+var rnds8Pool = new Uint8Array(256);
+var poolPtr = rnds8Pool.length;
+function rng() {
+  if (poolPtr > rnds8Pool.length - 16) {
+    import_node_crypto.default.randomFillSync(rnds8Pool);
+    poolPtr = 0;
+  }
+  return rnds8Pool.slice(poolPtr, poolPtr += 16);
+}
+
+// node_modules/.pnpm/uuid@10.0.0/node_modules/uuid/dist/esm-node/v7.js
+var _seqLow = null;
+var _seqHigh = null;
+var _msecs = 0;
+function v7(options, buf, offset) {
+  options = options || {};
+  let i = buf && offset || 0;
+  const b = buf || new Uint8Array(16);
+  const rnds = options.random || (options.rng || rng)();
+  const msecs = options.msecs !== void 0 ? options.msecs : Date.now();
+  let seq = options.seq !== void 0 ? options.seq : null;
+  let seqHigh = _seqHigh;
+  let seqLow = _seqLow;
+  if (msecs > _msecs && options.msecs === void 0) {
+    _msecs = msecs;
+    if (seq !== null) {
+      seqHigh = null;
+      seqLow = null;
     }
-    return 0;
   }
-};
-var V7Generator = class {
-  /**
-   * Creates a generator object with the default random number generator, or
-   * with the specified one if passed as an argument. The specified random
-   * number generator should be cryptographically strong and securely seeded.
-   */
-  constructor(randomNumberGenerator) {
-    this.timestamp = 0;
-    this.counter = 0;
-    this.random = randomNumberGenerator !== null && randomNumberGenerator !== void 0 ? randomNumberGenerator : getDefaultRandom();
-  }
-  /**
-   * Generates a new UUIDv7 object from the current timestamp, or resets the
-   * generator upon significant timestamp rollback.
-   *
-   * This method returns monotonically increasing UUIDs unless the up-to-date
-   * timestamp is significantly (by more than ten seconds) smaller than the one
-   * embedded in the immediately preceding UUID. If such a significant clock
-   * rollback is detected, this method resets the generator and returns a new
-   * UUID based on the current timestamp.
-   */
-  generate() {
-    return this.generateOrResetCore(Date.now(), 1e4);
-  }
-  /**
-   * Generates a new UUIDv7 object from the current timestamp, or returns
-   * `undefined` upon significant timestamp rollback.
-   *
-   * This method returns monotonically increasing UUIDs unless the up-to-date
-   * timestamp is significantly (by more than ten seconds) smaller than the one
-   * embedded in the immediately preceding UUID. If such a significant clock
-   * rollback is detected, this method aborts and returns `undefined`.
-   */
-  generateOrAbort() {
-    return this.generateOrAbortCore(Date.now(), 1e4);
-  }
-  /**
-   * Generates a new UUIDv7 object from the `unixTsMs` passed, or resets the
-   * generator upon significant timestamp rollback.
-   *
-   * This method is equivalent to {@link generate} except that it takes a custom
-   * timestamp and clock rollback allowance.
-   *
-   * @param rollbackAllowance - The amount of `unixTsMs` rollback that is
-   * considered significant. A suggested value is `10_000` (milliseconds).
-   * @throws RangeError if `unixTsMs` is not a 48-bit positive integer.
-   */
-  generateOrResetCore(unixTsMs, rollbackAllowance) {
-    let value = this.generateOrAbortCore(unixTsMs, rollbackAllowance);
-    if (value === void 0) {
-      this.timestamp = 0;
-      value = this.generateOrAbortCore(unixTsMs, rollbackAllowance);
-    }
-    return value;
-  }
-  /**
-   * Generates a new UUIDv7 object from the `unixTsMs` passed, or returns
-   * `undefined` upon significant timestamp rollback.
-   *
-   * This method is equivalent to {@link generateOrAbort} except that it takes a
-   * custom timestamp and clock rollback allowance.
-   *
-   * @param rollbackAllowance - The amount of `unixTsMs` rollback that is
-   * considered significant. A suggested value is `10_000` (milliseconds).
-   * @throws RangeError if `unixTsMs` is not a 48-bit positive integer.
-   */
-  generateOrAbortCore(unixTsMs, rollbackAllowance) {
-    const MAX_COUNTER = 4398046511103;
-    if (!Number.isInteger(unixTsMs) || unixTsMs < 1 || unixTsMs > 281474976710655) {
-      throw new RangeError("`unixTsMs` must be a 48-bit positive integer");
-    } else if (rollbackAllowance < 0 || rollbackAllowance > 281474976710655) {
-      throw new RangeError("`rollbackAllowance` out of reasonable range");
+  if (seq !== null) {
+    if (seq > 2147483647) {
+      seq = 2147483647;
     }
-    if (unixTsMs > this.timestamp) {
-      this.timestamp = unixTsMs;
-      this.resetCounter();
-    } else if (unixTsMs + rollbackAllowance >= this.timestamp) {
-      this.counter++;
-      if (this.counter > MAX_COUNTER) {
-        this.timestamp++;
-        this.resetCounter();
+    seqHigh = seq >>> 19 & 4095;
+    seqLow = seq & 524287;
+  }
+  if (seqHigh === null || seqLow === null) {
+    seqHigh = rnds[6] & 127;
+    seqHigh = seqHigh << 8 | rnds[7];
+    seqLow = rnds[8] & 63;
+    seqLow = seqLow << 8 | rnds[9];
+    seqLow = seqLow << 5 | rnds[10] >>> 3;
+  }
+  if (msecs + 1e4 > _msecs && seq === null) {
+    if (++seqLow > 524287) {
+      seqLow = 0;
+      if (++seqHigh > 4095) {
+        seqHigh = 0;
+        _msecs++;
       }
-    } else {
-      return void 0;
     }
-    return UUID.fromFieldsV7(this.timestamp, Math.trunc(this.counter / __pow(2, 30)), this.counter & __pow(2, 30) - 1, this.random.nextUint32());
-  }
-  /** Initializes the counter at a 42-bit random integer. */
-  resetCounter() {
-    this.counter = this.random.nextUint32() * 1024 + (this.random.nextUint32() & 1023);
-  }
-  /**
-   * Generates a new UUIDv4 object utilizing the random number generator inside.
-   *
-   * @internal
-   */
-  generateV4() {
-    const bytes = new Uint8Array(Uint32Array.of(this.random.nextUint32(), this.random.nextUint32(), this.random.nextUint32(), this.random.nextUint32()).buffer);
-    bytes[6] = 64 | bytes[6] >>> 4;
-    bytes[8] = 128 | bytes[8] >>> 2;
-    return UUID.ofInner(bytes);
-  }
-};
-var getDefaultRandom = () => {
-  if (typeof crypto !== "undefined" && typeof crypto.getRandomValues !== "undefined") {
-    return new BufferedCryptoRandom();
   } else {
-    if (typeof UUIDV7_DENY_WEAK_RNG !== "undefined" && UUIDV7_DENY_WEAK_RNG) {
-      throw new Error("no cryptographically strong RNG available");
-    }
-    return {
-      nextUint32: () => Math.trunc(Math.random() * 65536) * 65536 + Math.trunc(Math.random() * 65536)
-    };
-  }
-};
-var BufferedCryptoRandom = class {
-  constructor() {
-    this.buffer = new Uint32Array(8);
-    this.cursor = 65535;
-  }
-  nextUint32() {
-    if (this.cursor >= this.buffer.length) {
-      crypto.getRandomValues(this.buffer);
-      this.cursor = 0;
-    }
-    return this.buffer[this.cursor++];
-  }
-};
-var defaultGenerator;
-var uuidv7obj = () => (defaultGenerator || (defaultGenerator = new V7Generator())).generate();
+    _msecs = msecs;
+  }
+  _seqHigh = seqHigh;
+  _seqLow = seqLow;
+  b[i++] = _msecs / 1099511627776 & 255;
+  b[i++] = _msecs / 4294967296 & 255;
+  b[i++] = _msecs / 16777216 & 255;
+  b[i++] = _msecs / 65536 & 255;
+  b[i++] = _msecs / 256 & 255;
+  b[i++] = _msecs & 255;
+  b[i++] = seqHigh >>> 4 & 15 | 112;
+  b[i++] = seqHigh & 255;
+  b[i++] = seqLow >>> 13 & 63 | 128;
+  b[i++] = seqLow >>> 5 & 255;
+  b[i++] = seqLow << 3 & 255 | rnds[10] & 7;
+  b[i++] = rnds[11];
+  b[i++] = rnds[12];
+  b[i++] = rnds[13];
+  b[i++] = rnds[14];
+  b[i++] = rnds[15];
+  return buf || unsafeStringify(b);
+}
+var v7_default = v7;
 
 // src/parse_uuid.ts
 function parseUUID(uuid) {
@@ -732,8 +529,9 @@ function typeidUnboxed(prefix = "", suffix = "") {
   if (suffix) {
     finalSuffix = suffix;
   } else {
-    const uuid = uuidv7obj();
-    finalSuffix = encode(uuid.bytes);
+    const buffer = new Uint8Array(16);
+    v7_default(void 0, buffer);
+    finalSuffix = encode(buffer);
   }
   if (finalSuffix.length !== 26) {
     throw new Error(
@@ -799,9 +597,7 @@ function toUUIDBytes(typeId) {
   return decode(getSuffix(typeId));
 }
 function toUUID(typeId) {
-  const uuidBytes = toUUIDBytes(typeId);
-  const uuid = UUID.ofInner(uuidBytes);
-  return uuid.toString();
+  return stringify_default(toUUIDBytes(typeId));
 }
 function fromUUIDBytes(prefix, bytes) {
   const suffix = encode(bytes);
@@ -840,8 +636,7 @@ var TypeID = class {
     return decode(this.suffix);
   }
   toUUID() {
-    const uuid = UUID.ofInner(this.toUUIDBytes());
-    return uuid.toString();
+    return stringify_default(this.toUUIDBytes());
   }
   toString() {
     if (this.prefix === "") {
@@ -879,15 +674,4 @@ function typeid(prefix = "", suffix = "") {
   typeid,
   typeidUnboxed
 });
-/*! Bundled license information:
-
-uuidv7/dist/index.js:
-  (**
-   * uuidv7: An experimental implementation of the proposed UUID Version 7
-   *
-   * @license Apache-2.0
-   * @copyright 2021-2023 LiosK
-   * @packageDocumentation
-   *)
-*/
 //# sourceMappingURL=index.js.map
\ No newline at end of file
diff --git a/dist/index.js.map b/dist/index.js.map
index c111e597728a884f50b71f3a79258ee953e036fe..4e1c6a36ed420b0ce58b1ab75f3ec9720e0ff18c 100644
--- a/dist/index.js.map
+++ b/dist/index.js.map
@@ -1 +1 @@
-{"version":3,"sources":["../src/index.ts","../node_modules/.pnpm/uuidv7@0.6.2/node_modules/uuidv7/dist/index.js","../src/parse_uuid.ts","../src/base32.ts","../src/prefix.ts","../src/unboxed/typeid.ts","../src/typeid.ts"],"sourcesContent":["export { typeid, TypeID } from \"./typeid\";\nexport {\n  type TypeId,\n  typeidUnboxed,\n  fromString,\n  parseTypeId,\n  getType,\n  getSuffix,\n  toUUIDBytes,\n  toUUID,\n  fromUUIDBytes,\n  fromUUID,\n} from \"./unboxed/typeid\";\n","/**\n * uuidv7: An experimental implementation of the proposed UUID Version 7\n *\n * @license Apache-2.0\n * @copyright 2021-2023 LiosK\n * @packageDocumentation\n */\nconst DIGITS = \"0123456789abcdef\";\n/** Represents a UUID as a 16-byte byte array. */\nexport class UUID {\n    /** @param bytes - The 16-byte byte array representation. */\n    constructor(bytes) {\n        this.bytes = bytes;\n    }\n    /**\n     * Creates an object from the internal representation, a 16-byte byte array\n     * containing the binary UUID representation in the big-endian byte order.\n     *\n     * This method does NOT shallow-copy the argument, and thus the created object\n     * holds the reference to the underlying buffer.\n     *\n     * @throws TypeError if the length of the argument is not 16.\n     */\n    static ofInner(bytes) {\n        if (bytes.length !== 16) {\n            throw new TypeError(\"not 128-bit length\");\n        }\n        else {\n            return new UUID(bytes);\n        }\n    }\n    /**\n     * Builds a byte array from UUIDv7 field values.\n     *\n     * @param unixTsMs - A 48-bit `unix_ts_ms` field value.\n     * @param randA - A 12-bit `rand_a` field value.\n     * @param randBHi - The higher 30 bits of 62-bit `rand_b` field value.\n     * @param randBLo - The lower 32 bits of 62-bit `rand_b` field value.\n     * @throws RangeError if any field value is out of the specified range.\n     */\n    static fromFieldsV7(unixTsMs, randA, randBHi, randBLo) {\n        if (!Number.isInteger(unixTsMs) ||\n            !Number.isInteger(randA) ||\n            !Number.isInteger(randBHi) ||\n            !Number.isInteger(randBLo) ||\n            unixTsMs < 0 ||\n            randA < 0 ||\n            randBHi < 0 ||\n            randBLo < 0 ||\n            unixTsMs > 281474976710655 ||\n            randA > 0xfff ||\n            randBHi > 1073741823 ||\n            randBLo > 4294967295) {\n            throw new RangeError(\"invalid field value\");\n        }\n        const bytes = new Uint8Array(16);\n        bytes[0] = unixTsMs / 2 ** 40;\n        bytes[1] = unixTsMs / 2 ** 32;\n        bytes[2] = unixTsMs / 2 ** 24;\n        bytes[3] = unixTsMs / 2 ** 16;\n        bytes[4] = unixTsMs / 2 ** 8;\n        bytes[5] = unixTsMs;\n        bytes[6] = 0x70 | (randA >>> 8);\n        bytes[7] = randA;\n        bytes[8] = 0x80 | (randBHi >>> 24);\n        bytes[9] = randBHi >>> 16;\n        bytes[10] = randBHi >>> 8;\n        bytes[11] = randBHi;\n        bytes[12] = randBLo >>> 24;\n        bytes[13] = randBLo >>> 16;\n        bytes[14] = randBLo >>> 8;\n        bytes[15] = randBLo;\n        return new UUID(bytes);\n    }\n    /**\n     * Builds a byte array from a string representation.\n     *\n     * This method accepts the following formats:\n     *\n     * - 32-digit hexadecimal format without hyphens: `0189dcd553117d408db09496a2eef37b`\n     * - 8-4-4-4-12 hyphenated format: `0189dcd5-5311-7d40-8db0-9496a2eef37b`\n     * - Hyphenated format with surrounding braces: `{0189dcd5-5311-7d40-8db0-9496a2eef37b}`\n     * - RFC 4122 URN format: `urn:uuid:0189dcd5-5311-7d40-8db0-9496a2eef37b`\n     *\n     * Leading and trailing whitespaces represents an error.\n     *\n     * @throws SyntaxError if the argument could not parse as a valid UUID string.\n     */\n    static parse(uuid) {\n        var _a, _b, _c, _d;\n        let hex = undefined;\n        switch (uuid.length) {\n            case 32:\n                hex = (_a = /^[0-9a-f]{32}$/i.exec(uuid)) === null || _a === void 0 ? void 0 : _a[0];\n                break;\n            case 36:\n                hex =\n                    (_b = /^([0-9a-f]{8})-([0-9a-f]{4})-([0-9a-f]{4})-([0-9a-f]{4})-([0-9a-f]{12})$/i\n                        .exec(uuid)) === null || _b === void 0 ? void 0 : _b.slice(1, 6).join(\"\");\n                break;\n            case 38:\n                hex =\n                    (_c = /^\\{([0-9a-f]{8})-([0-9a-f]{4})-([0-9a-f]{4})-([0-9a-f]{4})-([0-9a-f]{12})\\}$/i\n                        .exec(uuid)) === null || _c === void 0 ? void 0 : _c.slice(1, 6).join(\"\");\n                break;\n            case 45:\n                hex =\n                    (_d = /^urn:uuid:([0-9a-f]{8})-([0-9a-f]{4})-([0-9a-f]{4})-([0-9a-f]{4})-([0-9a-f]{12})$/i\n                        .exec(uuid)) === null || _d === void 0 ? void 0 : _d.slice(1, 6).join(\"\");\n                break;\n            default:\n                break;\n        }\n        if (hex) {\n            const inner = new Uint8Array(16);\n            for (let i = 0; i < 16; i += 4) {\n                const n = parseInt(hex.substring(2 * i, 2 * i + 8), 16);\n                inner[i + 0] = n >>> 24;\n                inner[i + 1] = n >>> 16;\n                inner[i + 2] = n >>> 8;\n                inner[i + 3] = n;\n            }\n            return new UUID(inner);\n        }\n        else {\n            throw new SyntaxError(\"could not parse UUID string\");\n        }\n    }\n    /**\n     * @returns The 8-4-4-4-12 canonical hexadecimal string representation\n     * (`0189dcd5-5311-7d40-8db0-9496a2eef37b`).\n     */\n    toString() {\n        let text = \"\";\n        for (let i = 0; i < this.bytes.length; i++) {\n            text += DIGITS.charAt(this.bytes[i] >>> 4);\n            text += DIGITS.charAt(this.bytes[i] & 0xf);\n            if (i === 3 || i === 5 || i === 7 || i === 9) {\n                text += \"-\";\n            }\n        }\n        return text;\n    }\n    /**\n     * @returns The 32-digit hexadecimal representation without hyphens\n     * (`0189dcd553117d408db09496a2eef37b`).\n     */\n    toHex() {\n        let text = \"\";\n        for (let i = 0; i < this.bytes.length; i++) {\n            text += DIGITS.charAt(this.bytes[i] >>> 4);\n            text += DIGITS.charAt(this.bytes[i] & 0xf);\n        }\n        return text;\n    }\n    /** @returns The 8-4-4-4-12 canonical hexadecimal string representation. */\n    toJSON() {\n        return this.toString();\n    }\n    /**\n     * Reports the variant field value of the UUID or, if appropriate, \"NIL\" or\n     * \"MAX\".\n     *\n     * For convenience, this method reports \"NIL\" or \"MAX\" if `this` represents\n     * the Nil or Max UUID, although the Nil and Max UUIDs are technically\n     * subsumed under the variants `0b0` and `0b111`, respectively.\n     */\n    getVariant() {\n        const n = this.bytes[8] >>> 4;\n        if (n < 0) {\n            throw new Error(\"unreachable\");\n        }\n        else if (n <= 0b0111) {\n            return this.bytes.every((e) => e === 0) ? \"NIL\" : \"VAR_0\";\n        }\n        else if (n <= 0b1011) {\n            return \"VAR_10\";\n        }\n        else if (n <= 0b1101) {\n            return \"VAR_110\";\n        }\n        else if (n <= 0b1111) {\n            return this.bytes.every((e) => e === 0xff) ? \"MAX\" : \"VAR_RESERVED\";\n        }\n        else {\n            throw new Error(\"unreachable\");\n        }\n    }\n    /**\n     * Returns the version field value of the UUID or `undefined` if the UUID does\n     * not have the variant field value of `0b10`.\n     */\n    getVersion() {\n        return this.getVariant() === \"VAR_10\" ? this.bytes[6] >>> 4 : undefined;\n    }\n    /** Creates an object from `this`. */\n    clone() {\n        return new UUID(this.bytes.slice(0));\n    }\n    /** Returns true if `this` is equivalent to `other`. */\n    equals(other) {\n        return this.compareTo(other) === 0;\n    }\n    /**\n     * Returns a negative integer, zero, or positive integer if `this` is less\n     * than, equal to, or greater than `other`, respectively.\n     */\n    compareTo(other) {\n        for (let i = 0; i < 16; i++) {\n            const diff = this.bytes[i] - other.bytes[i];\n            if (diff !== 0) {\n                return Math.sign(diff);\n            }\n        }\n        return 0;\n    }\n}\n/**\n * Encapsulates the monotonic counter state.\n *\n * This class provides APIs to utilize a separate counter state from that of the\n * global generator used by {@link uuidv7} and {@link uuidv7obj}. In addition to\n * the default {@link generate} method, this class has {@link generateOrAbort}\n * that is useful to absolutely guarantee the monotonically increasing order of\n * generated UUIDs despite a significant rollback of the system clock.\n */\nexport class V7Generator {\n    /**\n     * Creates a generator object with the default random number generator, or\n     * with the specified one if passed as an argument. The specified random\n     * number generator should be cryptographically strong and securely seeded.\n     */\n    constructor(randomNumberGenerator) {\n        this.timestamp = 0;\n        this.counter = 0;\n        this.random = randomNumberGenerator !== null && randomNumberGenerator !== void 0 ? randomNumberGenerator : getDefaultRandom();\n    }\n    /**\n     * Generates a new UUIDv7 object from the current timestamp, or resets the\n     * generator upon significant timestamp rollback.\n     *\n     * This method returns monotonically increasing UUIDs unless the up-to-date\n     * timestamp is significantly (by more than ten seconds) smaller than the one\n     * embedded in the immediately preceding UUID. If such a significant clock\n     * rollback is detected, this method resets the generator and returns a new\n     * UUID based on the current timestamp.\n     */\n    generate() {\n        return this.generateOrResetCore(Date.now(), 10000);\n    }\n    /**\n     * Generates a new UUIDv7 object from the current timestamp, or returns\n     * `undefined` upon significant timestamp rollback.\n     *\n     * This method returns monotonically increasing UUIDs unless the up-to-date\n     * timestamp is significantly (by more than ten seconds) smaller than the one\n     * embedded in the immediately preceding UUID. If such a significant clock\n     * rollback is detected, this method aborts and returns `undefined`.\n     */\n    generateOrAbort() {\n        return this.generateOrAbortCore(Date.now(), 10000);\n    }\n    /**\n     * Generates a new UUIDv7 object from the `unixTsMs` passed, or resets the\n     * generator upon significant timestamp rollback.\n     *\n     * This method is equivalent to {@link generate} except that it takes a custom\n     * timestamp and clock rollback allowance.\n     *\n     * @param rollbackAllowance - The amount of `unixTsMs` rollback that is\n     * considered significant. A suggested value is `10_000` (milliseconds).\n     * @throws RangeError if `unixTsMs` is not a 48-bit positive integer.\n     */\n    generateOrResetCore(unixTsMs, rollbackAllowance) {\n        let value = this.generateOrAbortCore(unixTsMs, rollbackAllowance);\n        if (value === undefined) {\n            // reset state and resume\n            this.timestamp = 0;\n            value = this.generateOrAbortCore(unixTsMs, rollbackAllowance);\n        }\n        return value;\n    }\n    /**\n     * Generates a new UUIDv7 object from the `unixTsMs` passed, or returns\n     * `undefined` upon significant timestamp rollback.\n     *\n     * This method is equivalent to {@link generateOrAbort} except that it takes a\n     * custom timestamp and clock rollback allowance.\n     *\n     * @param rollbackAllowance - The amount of `unixTsMs` rollback that is\n     * considered significant. A suggested value is `10_000` (milliseconds).\n     * @throws RangeError if `unixTsMs` is not a 48-bit positive integer.\n     */\n    generateOrAbortCore(unixTsMs, rollbackAllowance) {\n        const MAX_COUNTER = 4398046511103;\n        if (!Number.isInteger(unixTsMs) ||\n            unixTsMs < 1 ||\n            unixTsMs > 281474976710655) {\n            throw new RangeError(\"`unixTsMs` must be a 48-bit positive integer\");\n        }\n        else if (rollbackAllowance < 0 || rollbackAllowance > 281474976710655) {\n            throw new RangeError(\"`rollbackAllowance` out of reasonable range\");\n        }\n        if (unixTsMs > this.timestamp) {\n            this.timestamp = unixTsMs;\n            this.resetCounter();\n        }\n        else if (unixTsMs + rollbackAllowance >= this.timestamp) {\n            // go on with previous timestamp if new one is not much smaller\n            this.counter++;\n            if (this.counter > MAX_COUNTER) {\n                // increment timestamp at counter overflow\n                this.timestamp++;\n                this.resetCounter();\n            }\n        }\n        else {\n            // abort if clock went backwards to unbearable extent\n            return undefined;\n        }\n        return UUID.fromFieldsV7(this.timestamp, Math.trunc(this.counter / 2 ** 30), this.counter & (2 ** 30 - 1), this.random.nextUint32());\n    }\n    /** Initializes the counter at a 42-bit random integer. */\n    resetCounter() {\n        this.counter =\n            this.random.nextUint32() * 0x400 + (this.random.nextUint32() & 0x3ff);\n    }\n    /**\n     * Generates a new UUIDv4 object utilizing the random number generator inside.\n     *\n     * @internal\n     */\n    generateV4() {\n        const bytes = new Uint8Array(Uint32Array.of(this.random.nextUint32(), this.random.nextUint32(), this.random.nextUint32(), this.random.nextUint32()).buffer);\n        bytes[6] = 0x40 | (bytes[6] >>> 4);\n        bytes[8] = 0x80 | (bytes[8] >>> 2);\n        return UUID.ofInner(bytes);\n    }\n}\n/** Returns the default random number generator available in the environment. */\nconst getDefaultRandom = () => {\n    // detect Web Crypto API\n    if (typeof crypto !== \"undefined\" &&\n        typeof crypto.getRandomValues !== \"undefined\") {\n        return new BufferedCryptoRandom();\n    }\n    else {\n        // fall back on Math.random() unless the flag is set to true\n        if (typeof UUIDV7_DENY_WEAK_RNG !== \"undefined\" && UUIDV7_DENY_WEAK_RNG) {\n            throw new Error(\"no cryptographically strong RNG available\");\n        }\n        return {\n            nextUint32: () => Math.trunc(Math.random() * 65536) * 65536 +\n                Math.trunc(Math.random() * 65536),\n        };\n    }\n};\n/**\n * Wraps `crypto.getRandomValues()` to enable buffering; this uses a small\n * buffer by default to avoid both unbearable throughput decline in some\n * environments and the waste of time and space for unused values.\n */\nclass BufferedCryptoRandom {\n    constructor() {\n        this.buffer = new Uint32Array(8);\n        this.cursor = 0xffff;\n    }\n    nextUint32() {\n        if (this.cursor >= this.buffer.length) {\n            crypto.getRandomValues(this.buffer);\n            this.cursor = 0;\n        }\n        return this.buffer[this.cursor++];\n    }\n}\nlet defaultGenerator;\n/**\n * Generates a UUIDv7 string.\n *\n * @returns The 8-4-4-4-12 canonical hexadecimal string representation\n * (\"xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx\").\n */\nexport const uuidv7 = () => uuidv7obj().toString();\n/** Generates a UUIDv7 object. */\nexport const uuidv7obj = () => (defaultGenerator || (defaultGenerator = new V7Generator())).generate();\n/**\n * Generates a UUIDv4 string.\n *\n * @returns The 8-4-4-4-12 canonical hexadecimal string representation\n * (\"xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx\").\n */\nexport const uuidv4 = () => uuidv4obj().toString();\n/** Generates a UUIDv4 object. */\nexport const uuidv4obj = () => (defaultGenerator || (defaultGenerator = new V7Generator())).generateV4();\n","/* eslint-disable no-bitwise */\nexport function parseUUID(uuid: string) {\n  let v;\n  const arr = new Uint8Array(16);\n\n  // Block 1\n  arr[0] = (v = parseInt(uuid.slice(0, 8), 16)) >>> 24;\n  arr[1] = (v >>> 16) & 0xff;\n  arr[2] = (v >>> 8) & 0xff;\n  arr[3] = v & 0xff;\n\n  // Block 2\n  arr[4] = (v = parseInt(uuid.slice(9, 13), 16)) >>> 8;\n  arr[5] = v & 0xff;\n\n  // Block 3\n  arr[6] = (v = parseInt(uuid.slice(14, 18), 16)) >>> 8;\n  arr[7] = v & 0xff;\n\n  // Block 4\n  arr[8] = (v = parseInt(uuid.slice(19, 23), 16)) >>> 8;\n  arr[9] = v & 0xff;\n\n  // Block 5\n  arr[10] = ((v = parseInt(uuid.slice(24, 36), 16)) / 0x10000000000) & 0xff;\n  arr[11] = (v / 0x100000000) & 0xff;\n  arr[12] = (v >>> 24) & 0xff;\n  arr[13] = (v >>> 16) & 0xff;\n  arr[14] = (v >>> 8) & 0xff;\n  arr[15] = v & 0xff;\n\n  return arr;\n}\n","/* eslint-disable no-bitwise */\nconst alphabet: string = \"0123456789abcdefghjkmnpqrstvwxyz\";\n\n// Decoding table\nconst dec: Uint8Array = new Uint8Array([\n  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x01, 0x02, 0x03,\n  0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f, 0x10,\n  0x11, 0xff, 0x12, 0x13, 0xff, 0x14, 0x15, 0xff, 0x16, 0x17, 0x18, 0x19, 0x1a,\n  0xff, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n]);\n\nexport function encode(src: Uint8Array): string {\n  const dst: string[] = new Array(26).fill(\"\");\n\n  if (src.length !== 16) {\n    throw new Error(\n      `Invalid length. Expected 16 bytes, got ${src.length}. Input: ${src}`\n    );\n  }\n\n  // 10 byte timestamp\n  dst[0] = alphabet[(src[0] & 224) >> 5];\n  dst[1] = alphabet[src[0] & 31];\n  dst[2] = alphabet[(src[1] & 248) >> 3];\n  dst[3] = alphabet[((src[1] & 7) << 2) | ((src[2] & 192) >> 6)];\n  dst[4] = alphabet[(src[2] & 62) >> 1];\n  dst[5] = alphabet[((src[2] & 1) << 4) | ((src[3] & 240) >> 4)];\n  dst[6] = alphabet[((src[3] & 15) << 1) | ((src[4] & 128) >> 7)];\n  dst[7] = alphabet[(src[4] & 124) >> 2];\n  dst[8] = alphabet[((src[4] & 3) << 3) | ((src[5] & 224) >> 5)];\n  dst[9] = alphabet[src[5] & 31];\n\n  // 16 bytes of randomness\n  dst[10] = alphabet[(src[6] & 248) >> 3];\n  dst[11] = alphabet[((src[6] & 7) << 2) | ((src[7] & 192) >> 6)];\n  dst[12] = alphabet[(src[7] & 62) >> 1];\n  dst[13] = alphabet[((src[7] & 1) << 4) | ((src[8] & 240) >> 4)];\n  dst[14] = alphabet[((src[8] & 15) << 1) | ((src[9] & 128) >> 7)];\n  dst[15] = alphabet[(src[9] & 124) >> 2];\n  dst[16] = alphabet[((src[9] & 3) << 3) | ((src[10] & 224) >> 5)];\n  dst[17] = alphabet[src[10] & 31];\n  dst[18] = alphabet[(src[11] & 248) >> 3];\n  dst[19] = alphabet[((src[11] & 7) << 2) | ((src[12] & 192) >> 6)];\n  dst[20] = alphabet[(src[12] & 62) >> 1];\n  dst[21] = alphabet[((src[12] & 1) << 4) | ((src[13] & 240) >> 4)];\n  dst[22] = alphabet[((src[13] & 15) << 1) | ((src[14] & 128) >> 7)];\n  dst[23] = alphabet[(src[14] & 124) >> 2];\n  dst[24] = alphabet[((src[14] & 3) << 3) | ((src[15] & 224) >> 5)];\n  dst[25] = alphabet[src[15] & 31];\n\n  return dst.join(\"\");\n}\n\nexport function decode(s: string): Uint8Array {\n  if (s.length !== 26) {\n    throw new Error(\n      `Invalid length. Expected 26 bytes, got ${s.length}. Input: ${s}`\n    );\n  }\n\n  const encoder = new TextEncoder();\n  const v: Uint8Array = encoder.encode(s);\n\n  // Check if all the characters are part of the expected base32 character set.\n  if (\n    dec[v[0]] === 0xff ||\n    dec[v[1]] === 0xff ||\n    dec[v[2]] === 0xff ||\n    dec[v[3]] === 0xff ||\n    dec[v[4]] === 0xff ||\n    dec[v[5]] === 0xff ||\n    dec[v[6]] === 0xff ||\n    dec[v[7]] === 0xff ||\n    dec[v[8]] === 0xff ||\n    dec[v[9]] === 0xff ||\n    dec[v[10]] === 0xff ||\n    dec[v[11]] === 0xff ||\n    dec[v[12]] === 0xff ||\n    dec[v[13]] === 0xff ||\n    dec[v[14]] === 0xff ||\n    dec[v[15]] === 0xff ||\n    dec[v[16]] === 0xff ||\n    dec[v[17]] === 0xff ||\n    dec[v[18]] === 0xff ||\n    dec[v[19]] === 0xff ||\n    dec[v[20]] === 0xff ||\n    dec[v[21]] === 0xff ||\n    dec[v[22]] === 0xff ||\n    dec[v[23]] === 0xff ||\n    dec[v[24]] === 0xff ||\n    dec[v[25]] === 0xff\n  ) {\n    throw new Error(\"Invalid base32 character\");\n  }\n\n  const id = new Uint8Array(16);\n\n  // 6 bytes timestamp (48 bits)\n  id[0] = (dec[v[0]] << 5) | dec[v[1]];\n  id[1] = (dec[v[2]] << 3) | (dec[v[3]] >> 2);\n  id[2] = ((dec[v[3]] & 3) << 6) | (dec[v[4]] << 1) | (dec[v[5]] >> 4);\n  id[3] = ((dec[v[5]] & 15) << 4) | (dec[v[6]] >> 1);\n  id[4] = ((dec[v[6]] & 1) << 7) | (dec[v[7]] << 2) | (dec[v[8]] >> 3);\n  id[5] = ((dec[v[8]] & 7) << 5) | dec[v[9]];\n\n  // 10 bytes of entropy (80 bits)\n  id[6] = (dec[v[10]] << 3) | (dec[v[11]] >> 2);\n  id[7] = ((dec[v[11]] & 3) << 6) | (dec[v[12]] << 1) | (dec[v[13]] >> 4);\n  id[8] = ((dec[v[13]] & 15) << 4) | (dec[v[14]] >> 1);\n  id[9] = ((dec[v[14]] & 1) << 7) | (dec[v[15]] << 2) | (dec[v[16]] >> 3);\n  id[10] = ((dec[v[16]] & 7) << 5) | dec[v[17]];\n  id[11] = (dec[v[18]] << 3) | (dec[v[19]] >> 2);\n  id[12] = ((dec[v[19]] & 3) << 6) | (dec[v[20]] << 1) | (dec[v[21]] >> 4);\n  id[13] = ((dec[v[21]] & 15) << 4) | (dec[v[22]] >> 1);\n  id[14] = ((dec[v[22]] & 1) << 7) | (dec[v[23]] << 2) | (dec[v[24]] >> 3);\n  id[15] = ((dec[v[24]] & 7) << 5) | dec[v[25]];\n\n  return id;\n}\n","export function isValidPrefix(str: string): boolean {\n  if (str.length > 63) {\n    return false;\n  }\n\n  let code;\n  let i;\n  let len;\n\n  for (i = 0, len = str.length; i < len; i += 1) {\n    code = str.charCodeAt(i);\n    const isLowerAtoZ = code > 96 && code < 123;\n    const isUnderscore = code === 95;\n\n    // first and last char of prefix can only be [a-z]\n    if ((i === 0 || i === len - 1) && !isLowerAtoZ) {\n      return false;\n    }\n\n    if (!(isLowerAtoZ || isUnderscore)) {\n      return false;\n    }\n  }\n  return true;\n}\n","import { uuidv7obj, UUID } from \"uuidv7\";\nimport { parseUUID } from \"../parse_uuid\";\nimport { encode, decode } from \"../base32\";\nimport { isValidPrefix } from \"../prefix\";\n\nexport type TypeId<T> = string & { __type: T };\n\nexport function typeidUnboxed<T extends string>(\n  prefix: T = \"\" as T,\n  suffix: string = \"\"\n): TypeId<T> {\n  if (!isValidPrefix(prefix)) {\n    throw new Error(\"Invalid prefix. Must be at most 63 ascii letters [a-z_]\");\n  }\n\n  let finalSuffix: string;\n  if (suffix) {\n    finalSuffix = suffix;\n  } else {\n    const uuid = uuidv7obj();\n    finalSuffix = encode(uuid.bytes);\n  }\n\n  if (finalSuffix.length !== 26) {\n    throw new Error(\n      `Invalid length. Suffix should have 26 characters, got ${finalSuffix.length}`\n    );\n  }\n\n  if (finalSuffix[0] > \"7\") {\n    throw new Error(\n      \"Invalid suffix. First character must be in the range [0-7]\"\n    );\n  }\n\n  // Validate the suffix by decoding it. If it's invalid, an error will be thrown.\n  decode(finalSuffix);\n\n  if (prefix === \"\") {\n    return finalSuffix as TypeId<T>;\n  } else {\n    return `${prefix}_${finalSuffix}` as TypeId<T>;\n  }\n}\n\n/**\n * Constructs a TypeId from a string representation, optionally validating against a provided prefix.\n * This function splits the input `typeId` string by an underscore `_` to separate the prefix and suffix.\n * If the `typeId` contains no underscore, it is assumed to be a suffix with an empty prefix.\n * If a `prefix` is provided, it must match the prefix part of the `typeId`, or an error is thrown.\n *\n * @param {string} typeId - The string representation of the TypeId to be parsed.\n * @param {T} [prefix] - An optional prefix to validate against the prefix in the `typeId`.\n * @returns {TypeId<T>} A new TypeId instance constructed from the parsed `typeId`.\n * @throws {Error} If the `typeId` format is invalid, the prefix is empty when there's a separator,\n *                 or there's a prefix mismatch when a `prefix` is provided.\n * @template T - A string literal type that extends string.\n */\nexport function fromString<T extends string>(\n  typeId: string,\n  prefix?: T\n): TypeId<T> {\n  let p;\n  let s;\n\n  const underscoreIndex = typeId.lastIndexOf(\"_\");\n  if (underscoreIndex === -1) {\n    p = \"\" as T;\n    s = typeId;\n  } else {\n    p = typeId.substring(0, underscoreIndex) as T;\n    s = typeId.substring(underscoreIndex + 1);\n\n    if (!p) {\n      throw new Error(\n        `Invalid TypeId. Prefix cannot be empty when there's a separator: ${typeId}`\n      );\n    }\n  }\n\n  if (!s) {\n    throw new Error(`Invalid TypeId. Suffix cannot be empty`);\n  }\n\n  if (prefix && p !== prefix) {\n    throw new Error(\n      `Invalid TypeId. Prefix mismatch. Expected ${prefix}, got ${p}`\n    );\n  }\n\n  return typeidUnboxed(p, s);\n}\n\n/**\n * Parses a TypeId string into its prefix and suffix components.\n *\n * @param {TypeId<T>} typeId - The TypeId string to parse.\n * @returns {{ prefix: T; suffix: string }} An object containing the prefix and suffix of the TypeId.\n * @throws {Error} If the TypeId format is invalid (not exactly two parts separated by an underscore).\n *\n * @example\n * // For a valid TypeId 'example_00041061050r3gg28a1c60t3gf'\n * const { prefix, suffix } = parseTypeId('example_00041061050r3gg28a1c60t3gf');\n * console.log(prefix); // 'example'\n * console.log(suffix); // '00041061050r3gg28a1c60t3gf'\n *\n * @example\n * // Throws an error for invalid TypeId format\n * try {\n *   parseTypeId('invalidTypeId');\n * } catch (error) {\n *   console.error(error.message); // 'Invalid TypeId format: invalidTypeId'\n * }\n */\nexport function parseTypeId<T extends string>(\n  typeId: TypeId<T>\n): { prefix: T; suffix: string } {\n  return { prefix: getType(typeId), suffix: getSuffix(typeId) };\n}\n\n/**\n * Retrieves the prefix from a TypeId.\n *\n * @param {TypeId<T>} typeId - The TypeId from which to extract the prefix.\n * @returns {T} The prefix of the TypeId.\n */\nexport function getType<T extends string>(typeId: TypeId<T>): T {\n  const underscoreIndex = typeId.lastIndexOf(\"_\");\n  if (underscoreIndex === -1) {\n    return \"\" as T;\n  }\n  return typeId.substring(0, underscoreIndex) as T;\n}\n\n/**\n * Retrieves the suffix from a TypeId.\n *\n * @param {TypeId<T>} typeId - The TypeId from which to extract the suffix.\n * @returns {string} The suffix of the TypeId.\n */\nexport function getSuffix<T extends string>(typeId: TypeId<T>): string {\n  const underscoreIndex = typeId.lastIndexOf(\"_\");\n  if (underscoreIndex === -1) {\n    return typeId;\n  }\n  return typeId.substring(underscoreIndex + 1);\n}\n\nexport function toUUIDBytes<T extends string>(typeId: TypeId<T>): Uint8Array {\n  return decode(getSuffix(typeId));\n}\n\nexport function toUUID<T extends string>(typeId: TypeId<T>) {\n  const uuidBytes = toUUIDBytes(typeId);\n  const uuid = UUID.ofInner(uuidBytes);\n  return uuid.toString();\n}\n\nexport function fromUUIDBytes(\n  prefix: string,\n  bytes: Uint8Array\n): TypeId<typeof prefix> {\n  const suffix = encode(bytes);\n  return prefix\n    ? (`${prefix}_${suffix}` as TypeId<typeof prefix>)\n    : (suffix as TypeId<typeof prefix>);\n}\n\nexport function fromUUID<T extends string>(\n  uuid: string,\n  prefix?: T\n): TypeId<T> {\n  const suffix = encode(parseUUID(uuid));\n  return prefix ? (`${prefix}_${suffix}` as TypeId<T>) : (suffix as TypeId<T>);\n}\n","import { UUID } from \"uuidv7\";\nimport { parseUUID } from \"./parse_uuid\";\nimport { encode, decode } from \"./base32\";\nimport {\n  typeidUnboxed,\n  getSuffix,\n  getType,\n  fromString,\n} from \"./unboxed/typeid\";\n\nexport class TypeID<const T extends string> {\n  constructor(private prefix: T, private suffix: string = \"\") {\n    const typeIdRaw = typeidUnboxed(prefix, suffix);\n\n    this.prefix = getType(typeIdRaw);\n    this.suffix = getSuffix(typeIdRaw);\n  }\n\n  public getType(): T {\n    return this.prefix;\n  }\n\n  public getSuffix(): string {\n    return this.suffix;\n  }\n\n  public asType<const U extends string>(prefix: U): TypeID<U> {\n    const self = this as unknown as TypeID<U>;\n    if (self.prefix !== prefix) {\n      throw new Error(\n        `Cannot convert TypeID of type ${self.prefix} to type ${prefix}`\n      );\n    }\n    return self;\n  }\n\n  public toUUIDBytes(): Uint8Array {\n    return decode(this.suffix);\n  }\n\n  public toUUID(): string {\n    const uuid = UUID.ofInner(this.toUUIDBytes());\n    return uuid.toString();\n  }\n\n  public toString(): `${T}_${string}` | string {\n    if (this.prefix === \"\") {\n      return this.suffix;\n    }\n    return `${this.prefix}_${this.suffix}`;\n  }\n\n  static fromString<const T extends string>(\n    str: string,\n    prefix?: T\n  ): TypeID<T> {\n    const typeIdRaw = fromString(str, prefix);\n\n    return new TypeID<T>(getType(typeIdRaw) as T, getSuffix(typeIdRaw));\n  }\n\n  static fromUUIDBytes<const T extends string>(\n    prefix: T,\n    bytes: Uint8Array\n  ): TypeID<T> {\n    const suffix = encode(bytes);\n    return new TypeID(prefix, suffix);\n  }\n\n  static fromUUID<const T extends string>(prefix: T, uuid: string): TypeID<T> {\n    const suffix = encode(parseUUID(uuid));\n    return new TypeID(prefix, suffix);\n  }\n}\n\nexport function typeid<T extends string>(): TypeID<\"\">;\nexport function typeid<T extends string>(prefix: T): TypeID<T>;\nexport function typeid<T extends string>(prefix: T, suffix: string): TypeID<T>;\nexport function typeid<T extends string>(\n  prefix: T = \"\" as T,\n  suffix: string = \"\"\n): TypeID<T> {\n  return new TypeID(prefix, suffix);\n}\n"],"mappings":"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M;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EACxE;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EACxE;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EACxE;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EACxE;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EACxE;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EACxE;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EACxE;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EACxE;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EACxE;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM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","names":[]}
\ No newline at end of file
+{"version":3,"sources":["../src/index.ts","../node_modules/.pnpm/uuid@10.0.0/node_modules/uuid/dist/esm-node/regex.js","../node_modules/.pnpm/uuid@10.0.0/node_modules/uuid/dist/esm-node/validate.js","../node_modules/.pnpm/uuid@10.0.0/node_modules/uuid/dist/esm-node/stringify.js","../node_modules/.pnpm/uuid@10.0.0/node_modules/uuid/dist/esm-node/rng.js","../node_modules/.pnpm/uuid@10.0.0/node_modules/uuid/dist/esm-node/v7.js","../src/parse_uuid.ts","../src/base32.ts","../src/prefix.ts","../src/unboxed/typeid.ts","../src/typeid.ts"],"sourcesContent":["export { typeid, TypeID } from \"./typeid\";\nexport {\n  type TypeId,\n  typeidUnboxed,\n  fromString,\n  parseTypeId,\n  getType,\n  getSuffix,\n  toUUIDBytes,\n  toUUID,\n  fromUUIDBytes,\n  fromUUID,\n} from \"./unboxed/typeid\";\n","export default /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-8][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000|ffffffff-ffff-ffff-ffff-ffffffffffff)$/i;","import REGEX from './regex.js';\nfunction validate(uuid) {\n  return typeof uuid === 'string' && REGEX.test(uuid);\n}\nexport default validate;","import validate from './validate.js';\n\n/**\n * Convert array of 16 byte values to UUID string format of the form:\n * XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX\n */\nconst byteToHex = [];\nfor (let i = 0; i < 256; ++i) {\n  byteToHex.push((i + 0x100).toString(16).slice(1));\n}\nexport function unsafeStringify(arr, offset = 0) {\n  // Note: Be careful editing this code!  It's been tuned for performance\n  // and works in ways you may not expect. See https://github.com/uuidjs/uuid/pull/434\n  //\n  // Note to future-self: No, you can't remove the `toLowerCase()` call.\n  // REF: https://github.com/uuidjs/uuid/pull/677#issuecomment-1757351351\n  return (byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + '-' + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + '-' + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + '-' + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + '-' + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]]).toLowerCase();\n}\nfunction stringify(arr, offset = 0) {\n  const uuid = unsafeStringify(arr, offset);\n  // Consistency check for valid UUID.  If this throws, it's likely due to one\n  // of the following:\n  // - One or more input array values don't map to a hex octet (leading to\n  // \"undefined\" in the uuid)\n  // - Invalid input values for the RFC `version` or `variant` fields\n  if (!validate(uuid)) {\n    throw TypeError('Stringified UUID is invalid');\n  }\n  return uuid;\n}\nexport default stringify;","import crypto from 'node:crypto';\nconst rnds8Pool = new Uint8Array(256); // # of random values to pre-allocate\nlet poolPtr = rnds8Pool.length;\nexport default function rng() {\n  if (poolPtr > rnds8Pool.length - 16) {\n    crypto.randomFillSync(rnds8Pool);\n    poolPtr = 0;\n  }\n  return rnds8Pool.slice(poolPtr, poolPtr += 16);\n}","import rng from './rng.js';\nimport { unsafeStringify } from './stringify.js';\n\n/**\n * UUID V7 - Unix Epoch time-based UUID\n *\n * The IETF has published RFC9562, introducing 3 new UUID versions (6,7,8). This\n * implementation of V7 is based on the accepted, though not yet approved,\n * revisions.\n *\n * RFC 9562:https://www.rfc-editor.org/rfc/rfc9562.html Universally Unique\n * IDentifiers (UUIDs)\n\n *\n * Sample V7 value:\n * https://www.rfc-editor.org/rfc/rfc9562.html#name-example-of-a-uuidv7-value\n *\n * Monotonic Bit Layout: RFC rfc9562.6.2 Method 1, Dedicated Counter Bits ref:\n *     https://www.rfc-editor.org/rfc/rfc9562.html#section-6.2-5.1\n *\n *   0                   1                   2                   3 0 1 2 3 4 5 6\n *   7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n *  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n *  |                          unix_ts_ms                           |\n *  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n *  |          unix_ts_ms           |  ver  |        seq_hi         |\n *  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n *  |var|               seq_low               |        rand         |\n *  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n *  |                             rand                              |\n *  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n *\n * seq is a 31 bit serialized counter; comprised of 12 bit seq_hi and 19 bit\n * seq_low, and randomly initialized upon timestamp change. 31 bit counter size\n * was selected as any bitwise operations in node are done as _signed_ 32 bit\n * ints. we exclude the sign bit.\n */\n\nlet _seqLow = null;\nlet _seqHigh = null;\nlet _msecs = 0;\nfunction v7(options, buf, offset) {\n  options = options || {};\n\n  // initialize buffer and pointer\n  let i = buf && offset || 0;\n  const b = buf || new Uint8Array(16);\n\n  // rnds is Uint8Array(16) filled with random bytes\n  const rnds = options.random || (options.rng || rng)();\n\n  // milliseconds since unix epoch, 1970-01-01 00:00\n  const msecs = options.msecs !== undefined ? options.msecs : Date.now();\n\n  // seq is user provided 31 bit counter\n  let seq = options.seq !== undefined ? options.seq : null;\n\n  // initialize local seq high/low parts\n  let seqHigh = _seqHigh;\n  let seqLow = _seqLow;\n\n  // check if clock has advanced and user has not provided msecs\n  if (msecs > _msecs && options.msecs === undefined) {\n    _msecs = msecs;\n\n    // unless user provided seq, reset seq parts\n    if (seq !== null) {\n      seqHigh = null;\n      seqLow = null;\n    }\n  }\n\n  // if we have a user provided seq\n  if (seq !== null) {\n    // trim provided seq to 31 bits of value, avoiding overflow\n    if (seq > 0x7fffffff) {\n      seq = 0x7fffffff;\n    }\n\n    // split provided seq into high/low parts\n    seqHigh = seq >>> 19 & 0xfff;\n    seqLow = seq & 0x7ffff;\n  }\n\n  // randomly initialize seq\n  if (seqHigh === null || seqLow === null) {\n    seqHigh = rnds[6] & 0x7f;\n    seqHigh = seqHigh << 8 | rnds[7];\n    seqLow = rnds[8] & 0x3f; // pad for var\n    seqLow = seqLow << 8 | rnds[9];\n    seqLow = seqLow << 5 | rnds[10] >>> 3;\n  }\n\n  // increment seq if within msecs window\n  if (msecs + 10000 > _msecs && seq === null) {\n    if (++seqLow > 0x7ffff) {\n      seqLow = 0;\n      if (++seqHigh > 0xfff) {\n        seqHigh = 0;\n\n        // increment internal _msecs. this allows us to continue incrementing\n        // while staying monotonic. Note, once we hit 10k milliseconds beyond system\n        // clock, we will reset breaking monotonicity (after (2^31)*10000 generations)\n        _msecs++;\n      }\n    }\n  } else {\n    // resetting; we have advanced more than\n    // 10k milliseconds beyond system clock\n    _msecs = msecs;\n  }\n  _seqHigh = seqHigh;\n  _seqLow = seqLow;\n\n  // [bytes 0-5] 48 bits of local timestamp\n  b[i++] = _msecs / 0x10000000000 & 0xff;\n  b[i++] = _msecs / 0x100000000 & 0xff;\n  b[i++] = _msecs / 0x1000000 & 0xff;\n  b[i++] = _msecs / 0x10000 & 0xff;\n  b[i++] = _msecs / 0x100 & 0xff;\n  b[i++] = _msecs & 0xff;\n\n  // [byte 6] - set 4 bits of version (7) with first 4 bits seq_hi\n  b[i++] = seqHigh >>> 4 & 0x0f | 0x70;\n\n  // [byte 7] remaining 8 bits of seq_hi\n  b[i++] = seqHigh & 0xff;\n\n  // [byte 8] - variant (2 bits), first 6 bits seq_low\n  b[i++] = seqLow >>> 13 & 0x3f | 0x80;\n\n  // [byte 9] 8 bits seq_low\n  b[i++] = seqLow >>> 5 & 0xff;\n\n  // [byte 10] remaining 5 bits seq_low, 3 bits random\n  b[i++] = seqLow << 3 & 0xff | rnds[10] & 0x07;\n\n  // [bytes 11-15] always random\n  b[i++] = rnds[11];\n  b[i++] = rnds[12];\n  b[i++] = rnds[13];\n  b[i++] = rnds[14];\n  b[i++] = rnds[15];\n  return buf || unsafeStringify(b);\n}\nexport default v7;","/* eslint-disable no-bitwise */\nexport function parseUUID(uuid: string) {\n  let v;\n  const arr = new Uint8Array(16);\n\n  // Block 1\n  arr[0] = (v = parseInt(uuid.slice(0, 8), 16)) >>> 24;\n  arr[1] = (v >>> 16) & 0xff;\n  arr[2] = (v >>> 8) & 0xff;\n  arr[3] = v & 0xff;\n\n  // Block 2\n  arr[4] = (v = parseInt(uuid.slice(9, 13), 16)) >>> 8;\n  arr[5] = v & 0xff;\n\n  // Block 3\n  arr[6] = (v = parseInt(uuid.slice(14, 18), 16)) >>> 8;\n  arr[7] = v & 0xff;\n\n  // Block 4\n  arr[8] = (v = parseInt(uuid.slice(19, 23), 16)) >>> 8;\n  arr[9] = v & 0xff;\n\n  // Block 5\n  arr[10] = ((v = parseInt(uuid.slice(24, 36), 16)) / 0x10000000000) & 0xff;\n  arr[11] = (v / 0x100000000) & 0xff;\n  arr[12] = (v >>> 24) & 0xff;\n  arr[13] = (v >>> 16) & 0xff;\n  arr[14] = (v >>> 8) & 0xff;\n  arr[15] = v & 0xff;\n\n  return arr;\n}\n","/* eslint-disable no-bitwise */\nconst alphabet: string = \"0123456789abcdefghjkmnpqrstvwxyz\";\n\n// Decoding table\nconst dec: Uint8Array = new Uint8Array([\n  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x01, 0x02, 0x03,\n  0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f, 0x10,\n  0x11, 0xff, 0x12, 0x13, 0xff, 0x14, 0x15, 0xff, 0x16, 0x17, 0x18, 0x19, 0x1a,\n  0xff, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n]);\n\nexport function encode(src: Uint8Array): string {\n  const dst: string[] = new Array(26).fill(\"\");\n\n  if (src.length !== 16) {\n    throw new Error(\n      `Invalid length. Expected 16 bytes, got ${src.length}. Input: ${src}`\n    );\n  }\n\n  // 10 byte timestamp\n  dst[0] = alphabet[(src[0] & 224) >> 5];\n  dst[1] = alphabet[src[0] & 31];\n  dst[2] = alphabet[(src[1] & 248) >> 3];\n  dst[3] = alphabet[((src[1] & 7) << 2) | ((src[2] & 192) >> 6)];\n  dst[4] = alphabet[(src[2] & 62) >> 1];\n  dst[5] = alphabet[((src[2] & 1) << 4) | ((src[3] & 240) >> 4)];\n  dst[6] = alphabet[((src[3] & 15) << 1) | ((src[4] & 128) >> 7)];\n  dst[7] = alphabet[(src[4] & 124) >> 2];\n  dst[8] = alphabet[((src[4] & 3) << 3) | ((src[5] & 224) >> 5)];\n  dst[9] = alphabet[src[5] & 31];\n\n  // 16 bytes of randomness\n  dst[10] = alphabet[(src[6] & 248) >> 3];\n  dst[11] = alphabet[((src[6] & 7) << 2) | ((src[7] & 192) >> 6)];\n  dst[12] = alphabet[(src[7] & 62) >> 1];\n  dst[13] = alphabet[((src[7] & 1) << 4) | ((src[8] & 240) >> 4)];\n  dst[14] = alphabet[((src[8] & 15) << 1) | ((src[9] & 128) >> 7)];\n  dst[15] = alphabet[(src[9] & 124) >> 2];\n  dst[16] = alphabet[((src[9] & 3) << 3) | ((src[10] & 224) >> 5)];\n  dst[17] = alphabet[src[10] & 31];\n  dst[18] = alphabet[(src[11] & 248) >> 3];\n  dst[19] = alphabet[((src[11] & 7) << 2) | ((src[12] & 192) >> 6)];\n  dst[20] = alphabet[(src[12] & 62) >> 1];\n  dst[21] = alphabet[((src[12] & 1) << 4) | ((src[13] & 240) >> 4)];\n  dst[22] = alphabet[((src[13] & 15) << 1) | ((src[14] & 128) >> 7)];\n  dst[23] = alphabet[(src[14] & 124) >> 2];\n  dst[24] = alphabet[((src[14] & 3) << 3) | ((src[15] & 224) >> 5)];\n  dst[25] = alphabet[src[15] & 31];\n\n  return dst.join(\"\");\n}\n\nexport function decode(s: string): Uint8Array {\n  if (s.length !== 26) {\n    throw new Error(\n      `Invalid length. Expected 26 bytes, got ${s.length}. Input: ${s}`\n    );\n  }\n\n  const encoder = new TextEncoder();\n  const v: Uint8Array = encoder.encode(s);\n\n  // Check if all the characters are part of the expected base32 character set.\n  if (\n    dec[v[0]] === 0xff ||\n    dec[v[1]] === 0xff ||\n    dec[v[2]] === 0xff ||\n    dec[v[3]] === 0xff ||\n    dec[v[4]] === 0xff ||\n    dec[v[5]] === 0xff ||\n    dec[v[6]] === 0xff ||\n    dec[v[7]] === 0xff ||\n    dec[v[8]] === 0xff ||\n    dec[v[9]] === 0xff ||\n    dec[v[10]] === 0xff ||\n    dec[v[11]] === 0xff ||\n    dec[v[12]] === 0xff ||\n    dec[v[13]] === 0xff ||\n    dec[v[14]] === 0xff ||\n    dec[v[15]] === 0xff ||\n    dec[v[16]] === 0xff ||\n    dec[v[17]] === 0xff ||\n    dec[v[18]] === 0xff ||\n    dec[v[19]] === 0xff ||\n    dec[v[20]] === 0xff ||\n    dec[v[21]] === 0xff ||\n    dec[v[22]] === 0xff ||\n    dec[v[23]] === 0xff ||\n    dec[v[24]] === 0xff ||\n    dec[v[25]] === 0xff\n  ) {\n    throw new Error(\"Invalid base32 character\");\n  }\n\n  const id = new Uint8Array(16);\n\n  // 6 bytes timestamp (48 bits)\n  id[0] = (dec[v[0]] << 5) | dec[v[1]];\n  id[1] = (dec[v[2]] << 3) | (dec[v[3]] >> 2);\n  id[2] = ((dec[v[3]] & 3) << 6) | (dec[v[4]] << 1) | (dec[v[5]] >> 4);\n  id[3] = ((dec[v[5]] & 15) << 4) | (dec[v[6]] >> 1);\n  id[4] = ((dec[v[6]] & 1) << 7) | (dec[v[7]] << 2) | (dec[v[8]] >> 3);\n  id[5] = ((dec[v[8]] & 7) << 5) | dec[v[9]];\n\n  // 10 bytes of entropy (80 bits)\n  id[6] = (dec[v[10]] << 3) | (dec[v[11]] >> 2);\n  id[7] = ((dec[v[11]] & 3) << 6) | (dec[v[12]] << 1) | (dec[v[13]] >> 4);\n  id[8] = ((dec[v[13]] & 15) << 4) | (dec[v[14]] >> 1);\n  id[9] = ((dec[v[14]] & 1) << 7) | (dec[v[15]] << 2) | (dec[v[16]] >> 3);\n  id[10] = ((dec[v[16]] & 7) << 5) | dec[v[17]];\n  id[11] = (dec[v[18]] << 3) | (dec[v[19]] >> 2);\n  id[12] = ((dec[v[19]] & 3) << 6) | (dec[v[20]] << 1) | (dec[v[21]] >> 4);\n  id[13] = ((dec[v[21]] & 15) << 4) | (dec[v[22]] >> 1);\n  id[14] = ((dec[v[22]] & 1) << 7) | (dec[v[23]] << 2) | (dec[v[24]] >> 3);\n  id[15] = ((dec[v[24]] & 7) << 5) | dec[v[25]];\n\n  return id;\n}\n","export function isValidPrefix(str: string): boolean {\n  if (str.length > 63) {\n    return false;\n  }\n\n  let code;\n  let i;\n  let len;\n\n  for (i = 0, len = str.length; i < len; i += 1) {\n    code = str.charCodeAt(i);\n    const isLowerAtoZ = code > 96 && code < 123;\n    const isUnderscore = code === 95;\n\n    // first and last char of prefix can only be [a-z]\n    if ((i === 0 || i === len - 1) && !isLowerAtoZ) {\n      return false;\n    }\n\n    if (!(isLowerAtoZ || isUnderscore)) {\n      return false;\n    }\n  }\n  return true;\n}\n","import { stringify, v7 } from \"uuid\";\nimport { parseUUID } from \"../parse_uuid\";\nimport { encode, decode } from \"../base32\";\nimport { isValidPrefix } from \"../prefix\";\n\nexport type TypeId<T> = string & { __type: T };\n\nexport function typeidUnboxed<T extends string>(\n  prefix: T = \"\" as T,\n  suffix: string = \"\"\n): TypeId<T> {\n  if (!isValidPrefix(prefix)) {\n    throw new Error(\"Invalid prefix. Must be at most 63 ascii letters [a-z_]\");\n  }\n\n  let finalSuffix: string;\n  if (suffix) {\n    finalSuffix = suffix;\n  } else {\n    const buffer = new Uint8Array(16);\n    v7(undefined, buffer);\n    finalSuffix = encode(buffer);\n  }\n\n  if (finalSuffix.length !== 26) {\n    throw new Error(\n      `Invalid length. Suffix should have 26 characters, got ${finalSuffix.length}`\n    );\n  }\n\n  if (finalSuffix[0] > \"7\") {\n    throw new Error(\n      \"Invalid suffix. First character must be in the range [0-7]\"\n    );\n  }\n\n  // Validate the suffix by decoding it. If it's invalid, an error will be thrown.\n  decode(finalSuffix);\n\n  if (prefix === \"\") {\n    return finalSuffix as TypeId<T>;\n  } else {\n    return `${prefix}_${finalSuffix}` as TypeId<T>;\n  }\n}\n\n/**\n * Constructs a TypeId from a string representation, optionally validating against a provided prefix.\n * This function splits the input `typeId` string by an underscore `_` to separate the prefix and suffix.\n * If the `typeId` contains no underscore, it is assumed to be a suffix with an empty prefix.\n * If a `prefix` is provided, it must match the prefix part of the `typeId`, or an error is thrown.\n *\n * @param {string} typeId - The string representation of the TypeId to be parsed.\n * @param {T} [prefix] - An optional prefix to validate against the prefix in the `typeId`.\n * @returns {TypeId<T>} A new TypeId instance constructed from the parsed `typeId`.\n * @throws {Error} If the `typeId` format is invalid, the prefix is empty when there's a separator,\n *                 or there's a prefix mismatch when a `prefix` is provided.\n * @template T - A string literal type that extends string.\n */\nexport function fromString<T extends string>(\n  typeId: string,\n  prefix?: T\n): TypeId<T> {\n  let p;\n  let s;\n\n  const underscoreIndex = typeId.lastIndexOf(\"_\");\n  if (underscoreIndex === -1) {\n    p = \"\" as T;\n    s = typeId;\n  } else {\n    p = typeId.substring(0, underscoreIndex) as T;\n    s = typeId.substring(underscoreIndex + 1);\n\n    if (!p) {\n      throw new Error(\n        `Invalid TypeId. Prefix cannot be empty when there's a separator: ${typeId}`\n      );\n    }\n  }\n\n  if (!s) {\n    throw new Error(`Invalid TypeId. Suffix cannot be empty`);\n  }\n\n  if (prefix && p !== prefix) {\n    throw new Error(\n      `Invalid TypeId. Prefix mismatch. Expected ${prefix}, got ${p}`\n    );\n  }\n\n  return typeidUnboxed(p, s);\n}\n\n/**\n * Parses a TypeId string into its prefix and suffix components.\n *\n * @param {TypeId<T>} typeId - The TypeId string to parse.\n * @returns {{ prefix: T; suffix: string }} An object containing the prefix and suffix of the TypeId.\n * @throws {Error} If the TypeId format is invalid (not exactly two parts separated by an underscore).\n *\n * @example\n * // For a valid TypeId 'example_00041061050r3gg28a1c60t3gf'\n * const { prefix, suffix } = parseTypeId('example_00041061050r3gg28a1c60t3gf');\n * console.log(prefix); // 'example'\n * console.log(suffix); // '00041061050r3gg28a1c60t3gf'\n *\n * @example\n * // Throws an error for invalid TypeId format\n * try {\n *   parseTypeId('invalidTypeId');\n * } catch (error) {\n *   console.error(error.message); // 'Invalid TypeId format: invalidTypeId'\n * }\n */\nexport function parseTypeId<T extends string>(\n  typeId: TypeId<T>\n): { prefix: T; suffix: string } {\n  return { prefix: getType(typeId), suffix: getSuffix(typeId) };\n}\n\n/**\n * Retrieves the prefix from a TypeId.\n *\n * @param {TypeId<T>} typeId - The TypeId from which to extract the prefix.\n * @returns {T} The prefix of the TypeId.\n */\nexport function getType<T extends string>(typeId: TypeId<T>): T {\n  const underscoreIndex = typeId.lastIndexOf(\"_\");\n  if (underscoreIndex === -1) {\n    return \"\" as T;\n  }\n  return typeId.substring(0, underscoreIndex) as T;\n}\n\n/**\n * Retrieves the suffix from a TypeId.\n *\n * @param {TypeId<T>} typeId - The TypeId from which to extract the suffix.\n * @returns {string} The suffix of the TypeId.\n */\nexport function getSuffix<T extends string>(typeId: TypeId<T>): string {\n  const underscoreIndex = typeId.lastIndexOf(\"_\");\n  if (underscoreIndex === -1) {\n    return typeId;\n  }\n  return typeId.substring(underscoreIndex + 1);\n}\n\nexport function toUUIDBytes<T extends string>(typeId: TypeId<T>): Uint8Array {\n  return decode(getSuffix(typeId));\n}\n\nexport function toUUID<T extends string>(typeId: TypeId<T>) {\n  return stringify(toUUIDBytes(typeId));\n}\n\nexport function fromUUIDBytes(\n  prefix: string,\n  bytes: Uint8Array\n): TypeId<typeof prefix> {\n  const suffix = encode(bytes);\n  return prefix\n    ? (`${prefix}_${suffix}` as TypeId<typeof prefix>)\n    : (suffix as TypeId<typeof prefix>);\n}\n\nexport function fromUUID<T extends string>(\n  uuid: string,\n  prefix?: T\n): TypeId<T> {\n  const suffix = encode(parseUUID(uuid));\n  return prefix ? (`${prefix}_${suffix}` as TypeId<T>) : (suffix as TypeId<T>);\n}\n","import { stringify } from \"uuid\";\nimport { parseUUID } from \"./parse_uuid\";\nimport { encode, decode } from \"./base32\";\nimport {\n  typeidUnboxed,\n  getSuffix,\n  getType,\n  fromString,\n} from \"./unboxed/typeid\";\n\nexport class TypeID<const T extends string> {\n  constructor(private prefix: T, private suffix: string = \"\") {\n    const typeIdRaw = typeidUnboxed(prefix, suffix);\n\n    this.prefix = getType(typeIdRaw);\n    this.suffix = getSuffix(typeIdRaw);\n  }\n\n  public getType(): T {\n    return this.prefix;\n  }\n\n  public getSuffix(): string {\n    return this.suffix;\n  }\n\n  public asType<const U extends string>(prefix: U): TypeID<U> {\n    const self = this as unknown as TypeID<U>;\n    if (self.prefix !== prefix) {\n      throw new Error(\n        `Cannot convert TypeID of type ${self.prefix} to type ${prefix}`\n      );\n    }\n    return self;\n  }\n\n  public toUUIDBytes(): Uint8Array {\n    return decode(this.suffix);\n  }\n\n  public toUUID(): string {\n    return stringify(this.toUUIDBytes());\n  }\n\n  public toString(): `${T}_${string}` | string {\n    if (this.prefix === \"\") {\n      return this.suffix;\n    }\n    return `${this.prefix}_${this.suffix}`;\n  }\n\n  static fromString<const T extends string>(\n    str: string,\n    prefix?: T\n  ): TypeID<T> {\n    const typeIdRaw = fromString(str, prefix);\n\n    return new TypeID<T>(getType(typeIdRaw) as T, getSuffix(typeIdRaw));\n  }\n\n  static fromUUIDBytes<const T extends string>(\n    prefix: T,\n    bytes: Uint8Array\n  ): TypeID<T> {\n    const suffix = encode(bytes);\n    return new TypeID(prefix, suffix);\n  }\n\n  static fromUUID<const T extends string>(prefix: T, uuid: string): TypeID<T> {\n    const suffix = encode(parseUUID(uuid));\n    return new TypeID(prefix, suffix);\n  }\n}\n\nexport function typeid<T extends string>(): TypeID<\"\">;\nexport function typeid<T extends string>(prefix: T): TypeID<T>;\nexport function typeid<T extends string>(prefix: T, suffix: string): TypeID<T>;\nexport function typeid<T extends string>(\n  prefix: T = \"\" as T,\n  suffix: string = \"\"\n): TypeID<T> {\n  return new TypeID(prefix, suffix);\n}\n"],"mappings":"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EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EACxE;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EACxE;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EACxE;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EACxE;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EACxE;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EACxE;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EACxE;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EACxE;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EACxE;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EACxE;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EACxE;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EACxE;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EACxE;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EACxE;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EACxE;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EACxE;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EACxE;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EACxE;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EA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","names":["crypto"]}
\ No newline at end of file
diff --git a/dist/index.mjs b/dist/index.mjs
index bbd87d804ba43cc7a673e490bc0066fbe3d7052b..4129a54a496374b6045ee175ee3d775a64d55cf8 100644
--- a/dist/index.mjs
+++ b/dist/index.mjs
@@ -1,321 +1,107 @@
-var __pow = Math.pow;
+// node_modules/.pnpm/uuid@10.0.0/node_modules/uuid/dist/esm-node/regex.js
+var regex_default = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-8][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000|ffffffff-ffff-ffff-ffff-ffffffffffff)$/i;
 
-// node_modules/.pnpm/uuidv7@0.6.2/node_modules/uuidv7/dist/index.js
-var DIGITS = "0123456789abcdef";
-var UUID = class {
-  /** @param bytes - The 16-byte byte array representation. */
-  constructor(bytes) {
-    this.bytes = bytes;
-  }
-  /**
-   * Creates an object from the internal representation, a 16-byte byte array
-   * containing the binary UUID representation in the big-endian byte order.
-   *
-   * This method does NOT shallow-copy the argument, and thus the created object
-   * holds the reference to the underlying buffer.
-   *
-   * @throws TypeError if the length of the argument is not 16.
-   */
-  static ofInner(bytes) {
-    if (bytes.length !== 16) {
-      throw new TypeError("not 128-bit length");
-    } else {
-      return new UUID(bytes);
-    }
-  }
-  /**
-   * Builds a byte array from UUIDv7 field values.
-   *
-   * @param unixTsMs - A 48-bit `unix_ts_ms` field value.
-   * @param randA - A 12-bit `rand_a` field value.
-   * @param randBHi - The higher 30 bits of 62-bit `rand_b` field value.
-   * @param randBLo - The lower 32 bits of 62-bit `rand_b` field value.
-   * @throws RangeError if any field value is out of the specified range.
-   */
-  static fromFieldsV7(unixTsMs, randA, randBHi, randBLo) {
-    if (!Number.isInteger(unixTsMs) || !Number.isInteger(randA) || !Number.isInteger(randBHi) || !Number.isInteger(randBLo) || unixTsMs < 0 || randA < 0 || randBHi < 0 || randBLo < 0 || unixTsMs > 281474976710655 || randA > 4095 || randBHi > 1073741823 || randBLo > 4294967295) {
-      throw new RangeError("invalid field value");
-    }
-    const bytes = new Uint8Array(16);
-    bytes[0] = unixTsMs / __pow(2, 40);
-    bytes[1] = unixTsMs / __pow(2, 32);
-    bytes[2] = unixTsMs / __pow(2, 24);
-    bytes[3] = unixTsMs / __pow(2, 16);
-    bytes[4] = unixTsMs / __pow(2, 8);
-    bytes[5] = unixTsMs;
-    bytes[6] = 112 | randA >>> 8;
-    bytes[7] = randA;
-    bytes[8] = 128 | randBHi >>> 24;
-    bytes[9] = randBHi >>> 16;
-    bytes[10] = randBHi >>> 8;
-    bytes[11] = randBHi;
-    bytes[12] = randBLo >>> 24;
-    bytes[13] = randBLo >>> 16;
-    bytes[14] = randBLo >>> 8;
-    bytes[15] = randBLo;
-    return new UUID(bytes);
-  }
-  /**
-   * Builds a byte array from a string representation.
-   *
-   * This method accepts the following formats:
-   *
-   * - 32-digit hexadecimal format without hyphens: `0189dcd553117d408db09496a2eef37b`
-   * - 8-4-4-4-12 hyphenated format: `0189dcd5-5311-7d40-8db0-9496a2eef37b`
-   * - Hyphenated format with surrounding braces: `{0189dcd5-5311-7d40-8db0-9496a2eef37b}`
-   * - RFC 4122 URN format: `urn:uuid:0189dcd5-5311-7d40-8db0-9496a2eef37b`
-   *
-   * Leading and trailing whitespaces represents an error.
-   *
-   * @throws SyntaxError if the argument could not parse as a valid UUID string.
-   */
-  static parse(uuid) {
-    var _a, _b, _c, _d;
-    let hex = void 0;
-    switch (uuid.length) {
-      case 32:
-        hex = (_a = /^[0-9a-f]{32}$/i.exec(uuid)) === null || _a === void 0 ? void 0 : _a[0];
-        break;
-      case 36:
-        hex = (_b = /^([0-9a-f]{8})-([0-9a-f]{4})-([0-9a-f]{4})-([0-9a-f]{4})-([0-9a-f]{12})$/i.exec(uuid)) === null || _b === void 0 ? void 0 : _b.slice(1, 6).join("");
-        break;
-      case 38:
-        hex = (_c = /^\{([0-9a-f]{8})-([0-9a-f]{4})-([0-9a-f]{4})-([0-9a-f]{4})-([0-9a-f]{12})\}$/i.exec(uuid)) === null || _c === void 0 ? void 0 : _c.slice(1, 6).join("");
-        break;
-      case 45:
-        hex = (_d = /^urn:uuid:([0-9a-f]{8})-([0-9a-f]{4})-([0-9a-f]{4})-([0-9a-f]{4})-([0-9a-f]{12})$/i.exec(uuid)) === null || _d === void 0 ? void 0 : _d.slice(1, 6).join("");
-        break;
-      default:
-        break;
-    }
-    if (hex) {
-      const inner = new Uint8Array(16);
-      for (let i = 0; i < 16; i += 4) {
-        const n = parseInt(hex.substring(2 * i, 2 * i + 8), 16);
-        inner[i + 0] = n >>> 24;
-        inner[i + 1] = n >>> 16;
-        inner[i + 2] = n >>> 8;
-        inner[i + 3] = n;
-      }
-      return new UUID(inner);
-    } else {
-      throw new SyntaxError("could not parse UUID string");
-    }
-  }
-  /**
-   * @returns The 8-4-4-4-12 canonical hexadecimal string representation
-   * (`0189dcd5-5311-7d40-8db0-9496a2eef37b`).
-   */
-  toString() {
-    let text = "";
-    for (let i = 0; i < this.bytes.length; i++) {
-      text += DIGITS.charAt(this.bytes[i] >>> 4);
-      text += DIGITS.charAt(this.bytes[i] & 15);
-      if (i === 3 || i === 5 || i === 7 || i === 9) {
-        text += "-";
-      }
-    }
-    return text;
-  }
-  /**
-   * @returns The 32-digit hexadecimal representation without hyphens
-   * (`0189dcd553117d408db09496a2eef37b`).
-   */
-  toHex() {
-    let text = "";
-    for (let i = 0; i < this.bytes.length; i++) {
-      text += DIGITS.charAt(this.bytes[i] >>> 4);
-      text += DIGITS.charAt(this.bytes[i] & 15);
-    }
-    return text;
-  }
-  /** @returns The 8-4-4-4-12 canonical hexadecimal string representation. */
-  toJSON() {
-    return this.toString();
-  }
-  /**
-   * Reports the variant field value of the UUID or, if appropriate, "NIL" or
-   * "MAX".
-   *
-   * For convenience, this method reports "NIL" or "MAX" if `this` represents
-   * the Nil or Max UUID, although the Nil and Max UUIDs are technically
-   * subsumed under the variants `0b0` and `0b111`, respectively.
-   */
-  getVariant() {
-    const n = this.bytes[8] >>> 4;
-    if (n < 0) {
-      throw new Error("unreachable");
-    } else if (n <= 7) {
-      return this.bytes.every((e) => e === 0) ? "NIL" : "VAR_0";
-    } else if (n <= 11) {
-      return "VAR_10";
-    } else if (n <= 13) {
-      return "VAR_110";
-    } else if (n <= 15) {
-      return this.bytes.every((e) => e === 255) ? "MAX" : "VAR_RESERVED";
-    } else {
-      throw new Error("unreachable");
-    }
-  }
-  /**
-   * Returns the version field value of the UUID or `undefined` if the UUID does
-   * not have the variant field value of `0b10`.
-   */
-  getVersion() {
-    return this.getVariant() === "VAR_10" ? this.bytes[6] >>> 4 : void 0;
-  }
-  /** Creates an object from `this`. */
-  clone() {
-    return new UUID(this.bytes.slice(0));
-  }
-  /** Returns true if `this` is equivalent to `other`. */
-  equals(other) {
-    return this.compareTo(other) === 0;
-  }
-  /**
-   * Returns a negative integer, zero, or positive integer if `this` is less
-   * than, equal to, or greater than `other`, respectively.
-   */
-  compareTo(other) {
-    for (let i = 0; i < 16; i++) {
-      const diff = this.bytes[i] - other.bytes[i];
-      if (diff !== 0) {
-        return Math.sign(diff);
-      }
-    }
-    return 0;
-  }
-};
-var V7Generator = class {
-  /**
-   * Creates a generator object with the default random number generator, or
-   * with the specified one if passed as an argument. The specified random
-   * number generator should be cryptographically strong and securely seeded.
-   */
-  constructor(randomNumberGenerator) {
-    this.timestamp = 0;
-    this.counter = 0;
-    this.random = randomNumberGenerator !== null && randomNumberGenerator !== void 0 ? randomNumberGenerator : getDefaultRandom();
-  }
-  /**
-   * Generates a new UUIDv7 object from the current timestamp, or resets the
-   * generator upon significant timestamp rollback.
-   *
-   * This method returns monotonically increasing UUIDs unless the up-to-date
-   * timestamp is significantly (by more than ten seconds) smaller than the one
-   * embedded in the immediately preceding UUID. If such a significant clock
-   * rollback is detected, this method resets the generator and returns a new
-   * UUID based on the current timestamp.
-   */
-  generate() {
-    return this.generateOrResetCore(Date.now(), 1e4);
-  }
-  /**
-   * Generates a new UUIDv7 object from the current timestamp, or returns
-   * `undefined` upon significant timestamp rollback.
-   *
-   * This method returns monotonically increasing UUIDs unless the up-to-date
-   * timestamp is significantly (by more than ten seconds) smaller than the one
-   * embedded in the immediately preceding UUID. If such a significant clock
-   * rollback is detected, this method aborts and returns `undefined`.
-   */
-  generateOrAbort() {
-    return this.generateOrAbortCore(Date.now(), 1e4);
+// node_modules/.pnpm/uuid@10.0.0/node_modules/uuid/dist/esm-node/validate.js
+function validate(uuid) {
+  return typeof uuid === "string" && regex_default.test(uuid);
+}
+var validate_default = validate;
+
+// node_modules/.pnpm/uuid@10.0.0/node_modules/uuid/dist/esm-node/stringify.js
+var byteToHex = [];
+for (let i = 0; i < 256; ++i) {
+  byteToHex.push((i + 256).toString(16).slice(1));
+}
+function unsafeStringify(arr, offset = 0) {
+  return (byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + "-" + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + "-" + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + "-" + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + "-" + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]]).toLowerCase();
+}
+function stringify(arr, offset = 0) {
+  const uuid = unsafeStringify(arr, offset);
+  if (!validate_default(uuid)) {
+    throw TypeError("Stringified UUID is invalid");
   }
-  /**
-   * Generates a new UUIDv7 object from the `unixTsMs` passed, or resets the
-   * generator upon significant timestamp rollback.
-   *
-   * This method is equivalent to {@link generate} except that it takes a custom
-   * timestamp and clock rollback allowance.
-   *
-   * @param rollbackAllowance - The amount of `unixTsMs` rollback that is
-   * considered significant. A suggested value is `10_000` (milliseconds).
-   * @throws RangeError if `unixTsMs` is not a 48-bit positive integer.
-   */
-  generateOrResetCore(unixTsMs, rollbackAllowance) {
-    let value = this.generateOrAbortCore(unixTsMs, rollbackAllowance);
-    if (value === void 0) {
-      this.timestamp = 0;
-      value = this.generateOrAbortCore(unixTsMs, rollbackAllowance);
+  return uuid;
+}
+var stringify_default = stringify;
+
+// node_modules/.pnpm/uuid@10.0.0/node_modules/uuid/dist/esm-node/rng.js
+import crypto from "crypto";
+var rnds8Pool = new Uint8Array(256);
+var poolPtr = rnds8Pool.length;
+function rng() {
+  if (poolPtr > rnds8Pool.length - 16) {
+    crypto.randomFillSync(rnds8Pool);
+    poolPtr = 0;
+  }
+  return rnds8Pool.slice(poolPtr, poolPtr += 16);
+}
+
+// node_modules/.pnpm/uuid@10.0.0/node_modules/uuid/dist/esm-node/v7.js
+var _seqLow = null;
+var _seqHigh = null;
+var _msecs = 0;
+function v7(options, buf, offset) {
+  options = options || {};
+  let i = buf && offset || 0;
+  const b = buf || new Uint8Array(16);
+  const rnds = options.random || (options.rng || rng)();
+  const msecs = options.msecs !== void 0 ? options.msecs : Date.now();
+  let seq = options.seq !== void 0 ? options.seq : null;
+  let seqHigh = _seqHigh;
+  let seqLow = _seqLow;
+  if (msecs > _msecs && options.msecs === void 0) {
+    _msecs = msecs;
+    if (seq !== null) {
+      seqHigh = null;
+      seqLow = null;
     }
-    return value;
   }
-  /**
-   * Generates a new UUIDv7 object from the `unixTsMs` passed, or returns
-   * `undefined` upon significant timestamp rollback.
-   *
-   * This method is equivalent to {@link generateOrAbort} except that it takes a
-   * custom timestamp and clock rollback allowance.
-   *
-   * @param rollbackAllowance - The amount of `unixTsMs` rollback that is
-   * considered significant. A suggested value is `10_000` (milliseconds).
-   * @throws RangeError if `unixTsMs` is not a 48-bit positive integer.
-   */
-  generateOrAbortCore(unixTsMs, rollbackAllowance) {
-    const MAX_COUNTER = 4398046511103;
-    if (!Number.isInteger(unixTsMs) || unixTsMs < 1 || unixTsMs > 281474976710655) {
-      throw new RangeError("`unixTsMs` must be a 48-bit positive integer");
-    } else if (rollbackAllowance < 0 || rollbackAllowance > 281474976710655) {
-      throw new RangeError("`rollbackAllowance` out of reasonable range");
+  if (seq !== null) {
+    if (seq > 2147483647) {
+      seq = 2147483647;
     }
-    if (unixTsMs > this.timestamp) {
-      this.timestamp = unixTsMs;
-      this.resetCounter();
-    } else if (unixTsMs + rollbackAllowance >= this.timestamp) {
-      this.counter++;
-      if (this.counter > MAX_COUNTER) {
-        this.timestamp++;
-        this.resetCounter();
+    seqHigh = seq >>> 19 & 4095;
+    seqLow = seq & 524287;
+  }
+  if (seqHigh === null || seqLow === null) {
+    seqHigh = rnds[6] & 127;
+    seqHigh = seqHigh << 8 | rnds[7];
+    seqLow = rnds[8] & 63;
+    seqLow = seqLow << 8 | rnds[9];
+    seqLow = seqLow << 5 | rnds[10] >>> 3;
+  }
+  if (msecs + 1e4 > _msecs && seq === null) {
+    if (++seqLow > 524287) {
+      seqLow = 0;
+      if (++seqHigh > 4095) {
+        seqHigh = 0;
+        _msecs++;
       }
-    } else {
-      return void 0;
     }
-    return UUID.fromFieldsV7(this.timestamp, Math.trunc(this.counter / __pow(2, 30)), this.counter & __pow(2, 30) - 1, this.random.nextUint32());
-  }
-  /** Initializes the counter at a 42-bit random integer. */
-  resetCounter() {
-    this.counter = this.random.nextUint32() * 1024 + (this.random.nextUint32() & 1023);
-  }
-  /**
-   * Generates a new UUIDv4 object utilizing the random number generator inside.
-   *
-   * @internal
-   */
-  generateV4() {
-    const bytes = new Uint8Array(Uint32Array.of(this.random.nextUint32(), this.random.nextUint32(), this.random.nextUint32(), this.random.nextUint32()).buffer);
-    bytes[6] = 64 | bytes[6] >>> 4;
-    bytes[8] = 128 | bytes[8] >>> 2;
-    return UUID.ofInner(bytes);
-  }
-};
-var getDefaultRandom = () => {
-  if (typeof crypto !== "undefined" && typeof crypto.getRandomValues !== "undefined") {
-    return new BufferedCryptoRandom();
   } else {
-    if (typeof UUIDV7_DENY_WEAK_RNG !== "undefined" && UUIDV7_DENY_WEAK_RNG) {
-      throw new Error("no cryptographically strong RNG available");
-    }
-    return {
-      nextUint32: () => Math.trunc(Math.random() * 65536) * 65536 + Math.trunc(Math.random() * 65536)
-    };
-  }
-};
-var BufferedCryptoRandom = class {
-  constructor() {
-    this.buffer = new Uint32Array(8);
-    this.cursor = 65535;
-  }
-  nextUint32() {
-    if (this.cursor >= this.buffer.length) {
-      crypto.getRandomValues(this.buffer);
-      this.cursor = 0;
-    }
-    return this.buffer[this.cursor++];
-  }
-};
-var defaultGenerator;
-var uuidv7obj = () => (defaultGenerator || (defaultGenerator = new V7Generator())).generate();
+    _msecs = msecs;
+  }
+  _seqHigh = seqHigh;
+  _seqLow = seqLow;
+  b[i++] = _msecs / 1099511627776 & 255;
+  b[i++] = _msecs / 4294967296 & 255;
+  b[i++] = _msecs / 16777216 & 255;
+  b[i++] = _msecs / 65536 & 255;
+  b[i++] = _msecs / 256 & 255;
+  b[i++] = _msecs & 255;
+  b[i++] = seqHigh >>> 4 & 15 | 112;
+  b[i++] = seqHigh & 255;
+  b[i++] = seqLow >>> 13 & 63 | 128;
+  b[i++] = seqLow >>> 5 & 255;
+  b[i++] = seqLow << 3 & 255 | rnds[10] & 7;
+  b[i++] = rnds[11];
+  b[i++] = rnds[12];
+  b[i++] = rnds[13];
+  b[i++] = rnds[14];
+  b[i++] = rnds[15];
+  return buf || unsafeStringify(b);
+}
+var v7_default = v7;
 
 // src/parse_uuid.ts
 function parseUUID(uuid) {
@@ -697,8 +483,9 @@ function typeidUnboxed(prefix = "", suffix = "") {
   if (suffix) {
     finalSuffix = suffix;
   } else {
-    const uuid = uuidv7obj();
-    finalSuffix = encode(uuid.bytes);
+    const buffer = new Uint8Array(16);
+    v7_default(void 0, buffer);
+    finalSuffix = encode(buffer);
   }
   if (finalSuffix.length !== 26) {
     throw new Error(
@@ -764,9 +551,7 @@ function toUUIDBytes(typeId) {
   return decode(getSuffix(typeId));
 }
 function toUUID(typeId) {
-  const uuidBytes = toUUIDBytes(typeId);
-  const uuid = UUID.ofInner(uuidBytes);
-  return uuid.toString();
+  return stringify_default(toUUIDBytes(typeId));
 }
 function fromUUIDBytes(prefix, bytes) {
   const suffix = encode(bytes);
@@ -805,8 +590,7 @@ var TypeID = class {
     return decode(this.suffix);
   }
   toUUID() {
-    const uuid = UUID.ofInner(this.toUUIDBytes());
-    return uuid.toString();
+    return stringify_default(this.toUUIDBytes());
   }
   toString() {
     if (this.prefix === "") {
@@ -843,15 +627,4 @@ export {
   typeid,
   typeidUnboxed
 };
-/*! Bundled license information:
-
-uuidv7/dist/index.js:
-  (**
-   * uuidv7: An experimental implementation of the proposed UUID Version 7
-   *
-   * @license Apache-2.0
-   * @copyright 2021-2023 LiosK
-   * @packageDocumentation
-   *)
-*/
 //# sourceMappingURL=index.mjs.map
\ No newline at end of file
diff --git a/dist/index.mjs.map b/dist/index.mjs.map
index e9c5f4cceeeed0ef4983440bd4ce62b322be03ba..881bb58cb3e54b80d4c0ecb14fb0201e41cf84f2 100644
--- a/dist/index.mjs.map
+++ b/dist/index.mjs.map
@@ -1 +1 @@
-{"version":3,"sources":["../node_modules/.pnpm/uuidv7@0.6.2/node_modules/uuidv7/dist/index.js","../src/parse_uuid.ts","../src/base32.ts","../src/prefix.ts","../src/unboxed/typeid.ts","../src/typeid.ts"],"sourcesContent":["/**\n * uuidv7: An experimental implementation of the proposed UUID Version 7\n *\n * @license Apache-2.0\n * @copyright 2021-2023 LiosK\n * @packageDocumentation\n */\nconst DIGITS = \"0123456789abcdef\";\n/** Represents a UUID as a 16-byte byte array. */\nexport class UUID {\n    /** @param bytes - The 16-byte byte array representation. */\n    constructor(bytes) {\n        this.bytes = bytes;\n    }\n    /**\n     * Creates an object from the internal representation, a 16-byte byte array\n     * containing the binary UUID representation in the big-endian byte order.\n     *\n     * This method does NOT shallow-copy the argument, and thus the created object\n     * holds the reference to the underlying buffer.\n     *\n     * @throws TypeError if the length of the argument is not 16.\n     */\n    static ofInner(bytes) {\n        if (bytes.length !== 16) {\n            throw new TypeError(\"not 128-bit length\");\n        }\n        else {\n            return new UUID(bytes);\n        }\n    }\n    /**\n     * Builds a byte array from UUIDv7 field values.\n     *\n     * @param unixTsMs - A 48-bit `unix_ts_ms` field value.\n     * @param randA - A 12-bit `rand_a` field value.\n     * @param randBHi - The higher 30 bits of 62-bit `rand_b` field value.\n     * @param randBLo - The lower 32 bits of 62-bit `rand_b` field value.\n     * @throws RangeError if any field value is out of the specified range.\n     */\n    static fromFieldsV7(unixTsMs, randA, randBHi, randBLo) {\n        if (!Number.isInteger(unixTsMs) ||\n            !Number.isInteger(randA) ||\n            !Number.isInteger(randBHi) ||\n            !Number.isInteger(randBLo) ||\n            unixTsMs < 0 ||\n            randA < 0 ||\n            randBHi < 0 ||\n            randBLo < 0 ||\n            unixTsMs > 281474976710655 ||\n            randA > 0xfff ||\n            randBHi > 1073741823 ||\n            randBLo > 4294967295) {\n            throw new RangeError(\"invalid field value\");\n        }\n        const bytes = new Uint8Array(16);\n        bytes[0] = unixTsMs / 2 ** 40;\n        bytes[1] = unixTsMs / 2 ** 32;\n        bytes[2] = unixTsMs / 2 ** 24;\n        bytes[3] = unixTsMs / 2 ** 16;\n        bytes[4] = unixTsMs / 2 ** 8;\n        bytes[5] = unixTsMs;\n        bytes[6] = 0x70 | (randA >>> 8);\n        bytes[7] = randA;\n        bytes[8] = 0x80 | (randBHi >>> 24);\n        bytes[9] = randBHi >>> 16;\n        bytes[10] = randBHi >>> 8;\n        bytes[11] = randBHi;\n        bytes[12] = randBLo >>> 24;\n        bytes[13] = randBLo >>> 16;\n        bytes[14] = randBLo >>> 8;\n        bytes[15] = randBLo;\n        return new UUID(bytes);\n    }\n    /**\n     * Builds a byte array from a string representation.\n     *\n     * This method accepts the following formats:\n     *\n     * - 32-digit hexadecimal format without hyphens: `0189dcd553117d408db09496a2eef37b`\n     * - 8-4-4-4-12 hyphenated format: `0189dcd5-5311-7d40-8db0-9496a2eef37b`\n     * - Hyphenated format with surrounding braces: `{0189dcd5-5311-7d40-8db0-9496a2eef37b}`\n     * - RFC 4122 URN format: `urn:uuid:0189dcd5-5311-7d40-8db0-9496a2eef37b`\n     *\n     * Leading and trailing whitespaces represents an error.\n     *\n     * @throws SyntaxError if the argument could not parse as a valid UUID string.\n     */\n    static parse(uuid) {\n        var _a, _b, _c, _d;\n        let hex = undefined;\n        switch (uuid.length) {\n            case 32:\n                hex = (_a = /^[0-9a-f]{32}$/i.exec(uuid)) === null || _a === void 0 ? void 0 : _a[0];\n                break;\n            case 36:\n                hex =\n                    (_b = /^([0-9a-f]{8})-([0-9a-f]{4})-([0-9a-f]{4})-([0-9a-f]{4})-([0-9a-f]{12})$/i\n                        .exec(uuid)) === null || _b === void 0 ? void 0 : _b.slice(1, 6).join(\"\");\n                break;\n            case 38:\n                hex =\n                    (_c = /^\\{([0-9a-f]{8})-([0-9a-f]{4})-([0-9a-f]{4})-([0-9a-f]{4})-([0-9a-f]{12})\\}$/i\n                        .exec(uuid)) === null || _c === void 0 ? void 0 : _c.slice(1, 6).join(\"\");\n                break;\n            case 45:\n                hex =\n                    (_d = /^urn:uuid:([0-9a-f]{8})-([0-9a-f]{4})-([0-9a-f]{4})-([0-9a-f]{4})-([0-9a-f]{12})$/i\n                        .exec(uuid)) === null || _d === void 0 ? void 0 : _d.slice(1, 6).join(\"\");\n                break;\n            default:\n                break;\n        }\n        if (hex) {\n            const inner = new Uint8Array(16);\n            for (let i = 0; i < 16; i += 4) {\n                const n = parseInt(hex.substring(2 * i, 2 * i + 8), 16);\n                inner[i + 0] = n >>> 24;\n                inner[i + 1] = n >>> 16;\n                inner[i + 2] = n >>> 8;\n                inner[i + 3] = n;\n            }\n            return new UUID(inner);\n        }\n        else {\n            throw new SyntaxError(\"could not parse UUID string\");\n        }\n    }\n    /**\n     * @returns The 8-4-4-4-12 canonical hexadecimal string representation\n     * (`0189dcd5-5311-7d40-8db0-9496a2eef37b`).\n     */\n    toString() {\n        let text = \"\";\n        for (let i = 0; i < this.bytes.length; i++) {\n            text += DIGITS.charAt(this.bytes[i] >>> 4);\n            text += DIGITS.charAt(this.bytes[i] & 0xf);\n            if (i === 3 || i === 5 || i === 7 || i === 9) {\n                text += \"-\";\n            }\n        }\n        return text;\n    }\n    /**\n     * @returns The 32-digit hexadecimal representation without hyphens\n     * (`0189dcd553117d408db09496a2eef37b`).\n     */\n    toHex() {\n        let text = \"\";\n        for (let i = 0; i < this.bytes.length; i++) {\n            text += DIGITS.charAt(this.bytes[i] >>> 4);\n            text += DIGITS.charAt(this.bytes[i] & 0xf);\n        }\n        return text;\n    }\n    /** @returns The 8-4-4-4-12 canonical hexadecimal string representation. */\n    toJSON() {\n        return this.toString();\n    }\n    /**\n     * Reports the variant field value of the UUID or, if appropriate, \"NIL\" or\n     * \"MAX\".\n     *\n     * For convenience, this method reports \"NIL\" or \"MAX\" if `this` represents\n     * the Nil or Max UUID, although the Nil and Max UUIDs are technically\n     * subsumed under the variants `0b0` and `0b111`, respectively.\n     */\n    getVariant() {\n        const n = this.bytes[8] >>> 4;\n        if (n < 0) {\n            throw new Error(\"unreachable\");\n        }\n        else if (n <= 0b0111) {\n            return this.bytes.every((e) => e === 0) ? \"NIL\" : \"VAR_0\";\n        }\n        else if (n <= 0b1011) {\n            return \"VAR_10\";\n        }\n        else if (n <= 0b1101) {\n            return \"VAR_110\";\n        }\n        else if (n <= 0b1111) {\n            return this.bytes.every((e) => e === 0xff) ? \"MAX\" : \"VAR_RESERVED\";\n        }\n        else {\n            throw new Error(\"unreachable\");\n        }\n    }\n    /**\n     * Returns the version field value of the UUID or `undefined` if the UUID does\n     * not have the variant field value of `0b10`.\n     */\n    getVersion() {\n        return this.getVariant() === \"VAR_10\" ? this.bytes[6] >>> 4 : undefined;\n    }\n    /** Creates an object from `this`. */\n    clone() {\n        return new UUID(this.bytes.slice(0));\n    }\n    /** Returns true if `this` is equivalent to `other`. */\n    equals(other) {\n        return this.compareTo(other) === 0;\n    }\n    /**\n     * Returns a negative integer, zero, or positive integer if `this` is less\n     * than, equal to, or greater than `other`, respectively.\n     */\n    compareTo(other) {\n        for (let i = 0; i < 16; i++) {\n            const diff = this.bytes[i] - other.bytes[i];\n            if (diff !== 0) {\n                return Math.sign(diff);\n            }\n        }\n        return 0;\n    }\n}\n/**\n * Encapsulates the monotonic counter state.\n *\n * This class provides APIs to utilize a separate counter state from that of the\n * global generator used by {@link uuidv7} and {@link uuidv7obj}. In addition to\n * the default {@link generate} method, this class has {@link generateOrAbort}\n * that is useful to absolutely guarantee the monotonically increasing order of\n * generated UUIDs despite a significant rollback of the system clock.\n */\nexport class V7Generator {\n    /**\n     * Creates a generator object with the default random number generator, or\n     * with the specified one if passed as an argument. The specified random\n     * number generator should be cryptographically strong and securely seeded.\n     */\n    constructor(randomNumberGenerator) {\n        this.timestamp = 0;\n        this.counter = 0;\n        this.random = randomNumberGenerator !== null && randomNumberGenerator !== void 0 ? randomNumberGenerator : getDefaultRandom();\n    }\n    /**\n     * Generates a new UUIDv7 object from the current timestamp, or resets the\n     * generator upon significant timestamp rollback.\n     *\n     * This method returns monotonically increasing UUIDs unless the up-to-date\n     * timestamp is significantly (by more than ten seconds) smaller than the one\n     * embedded in the immediately preceding UUID. If such a significant clock\n     * rollback is detected, this method resets the generator and returns a new\n     * UUID based on the current timestamp.\n     */\n    generate() {\n        return this.generateOrResetCore(Date.now(), 10000);\n    }\n    /**\n     * Generates a new UUIDv7 object from the current timestamp, or returns\n     * `undefined` upon significant timestamp rollback.\n     *\n     * This method returns monotonically increasing UUIDs unless the up-to-date\n     * timestamp is significantly (by more than ten seconds) smaller than the one\n     * embedded in the immediately preceding UUID. If such a significant clock\n     * rollback is detected, this method aborts and returns `undefined`.\n     */\n    generateOrAbort() {\n        return this.generateOrAbortCore(Date.now(), 10000);\n    }\n    /**\n     * Generates a new UUIDv7 object from the `unixTsMs` passed, or resets the\n     * generator upon significant timestamp rollback.\n     *\n     * This method is equivalent to {@link generate} except that it takes a custom\n     * timestamp and clock rollback allowance.\n     *\n     * @param rollbackAllowance - The amount of `unixTsMs` rollback that is\n     * considered significant. A suggested value is `10_000` (milliseconds).\n     * @throws RangeError if `unixTsMs` is not a 48-bit positive integer.\n     */\n    generateOrResetCore(unixTsMs, rollbackAllowance) {\n        let value = this.generateOrAbortCore(unixTsMs, rollbackAllowance);\n        if (value === undefined) {\n            // reset state and resume\n            this.timestamp = 0;\n            value = this.generateOrAbortCore(unixTsMs, rollbackAllowance);\n        }\n        return value;\n    }\n    /**\n     * Generates a new UUIDv7 object from the `unixTsMs` passed, or returns\n     * `undefined` upon significant timestamp rollback.\n     *\n     * This method is equivalent to {@link generateOrAbort} except that it takes a\n     * custom timestamp and clock rollback allowance.\n     *\n     * @param rollbackAllowance - The amount of `unixTsMs` rollback that is\n     * considered significant. A suggested value is `10_000` (milliseconds).\n     * @throws RangeError if `unixTsMs` is not a 48-bit positive integer.\n     */\n    generateOrAbortCore(unixTsMs, rollbackAllowance) {\n        const MAX_COUNTER = 4398046511103;\n        if (!Number.isInteger(unixTsMs) ||\n            unixTsMs < 1 ||\n            unixTsMs > 281474976710655) {\n            throw new RangeError(\"`unixTsMs` must be a 48-bit positive integer\");\n        }\n        else if (rollbackAllowance < 0 || rollbackAllowance > 281474976710655) {\n            throw new RangeError(\"`rollbackAllowance` out of reasonable range\");\n        }\n        if (unixTsMs > this.timestamp) {\n            this.timestamp = unixTsMs;\n            this.resetCounter();\n        }\n        else if (unixTsMs + rollbackAllowance >= this.timestamp) {\n            // go on with previous timestamp if new one is not much smaller\n            this.counter++;\n            if (this.counter > MAX_COUNTER) {\n                // increment timestamp at counter overflow\n                this.timestamp++;\n                this.resetCounter();\n            }\n        }\n        else {\n            // abort if clock went backwards to unbearable extent\n            return undefined;\n        }\n        return UUID.fromFieldsV7(this.timestamp, Math.trunc(this.counter / 2 ** 30), this.counter & (2 ** 30 - 1), this.random.nextUint32());\n    }\n    /** Initializes the counter at a 42-bit random integer. */\n    resetCounter() {\n        this.counter =\n            this.random.nextUint32() * 0x400 + (this.random.nextUint32() & 0x3ff);\n    }\n    /**\n     * Generates a new UUIDv4 object utilizing the random number generator inside.\n     *\n     * @internal\n     */\n    generateV4() {\n        const bytes = new Uint8Array(Uint32Array.of(this.random.nextUint32(), this.random.nextUint32(), this.random.nextUint32(), this.random.nextUint32()).buffer);\n        bytes[6] = 0x40 | (bytes[6] >>> 4);\n        bytes[8] = 0x80 | (bytes[8] >>> 2);\n        return UUID.ofInner(bytes);\n    }\n}\n/** Returns the default random number generator available in the environment. */\nconst getDefaultRandom = () => {\n    // detect Web Crypto API\n    if (typeof crypto !== \"undefined\" &&\n        typeof crypto.getRandomValues !== \"undefined\") {\n        return new BufferedCryptoRandom();\n    }\n    else {\n        // fall back on Math.random() unless the flag is set to true\n        if (typeof UUIDV7_DENY_WEAK_RNG !== \"undefined\" && UUIDV7_DENY_WEAK_RNG) {\n            throw new Error(\"no cryptographically strong RNG available\");\n        }\n        return {\n            nextUint32: () => Math.trunc(Math.random() * 65536) * 65536 +\n                Math.trunc(Math.random() * 65536),\n        };\n    }\n};\n/**\n * Wraps `crypto.getRandomValues()` to enable buffering; this uses a small\n * buffer by default to avoid both unbearable throughput decline in some\n * environments and the waste of time and space for unused values.\n */\nclass BufferedCryptoRandom {\n    constructor() {\n        this.buffer = new Uint32Array(8);\n        this.cursor = 0xffff;\n    }\n    nextUint32() {\n        if (this.cursor >= this.buffer.length) {\n            crypto.getRandomValues(this.buffer);\n            this.cursor = 0;\n        }\n        return this.buffer[this.cursor++];\n    }\n}\nlet defaultGenerator;\n/**\n * Generates a UUIDv7 string.\n *\n * @returns The 8-4-4-4-12 canonical hexadecimal string representation\n * (\"xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx\").\n */\nexport const uuidv7 = () => uuidv7obj().toString();\n/** Generates a UUIDv7 object. */\nexport const uuidv7obj = () => (defaultGenerator || (defaultGenerator = new V7Generator())).generate();\n/**\n * Generates a UUIDv4 string.\n *\n * @returns The 8-4-4-4-12 canonical hexadecimal string representation\n * (\"xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx\").\n */\nexport const uuidv4 = () => uuidv4obj().toString();\n/** Generates a UUIDv4 object. */\nexport const uuidv4obj = () => (defaultGenerator || (defaultGenerator = new V7Generator())).generateV4();\n","/* eslint-disable no-bitwise */\nexport function parseUUID(uuid: string) {\n  let v;\n  const arr = new Uint8Array(16);\n\n  // Block 1\n  arr[0] = (v = parseInt(uuid.slice(0, 8), 16)) >>> 24;\n  arr[1] = (v >>> 16) & 0xff;\n  arr[2] = (v >>> 8) & 0xff;\n  arr[3] = v & 0xff;\n\n  // Block 2\n  arr[4] = (v = parseInt(uuid.slice(9, 13), 16)) >>> 8;\n  arr[5] = v & 0xff;\n\n  // Block 3\n  arr[6] = (v = parseInt(uuid.slice(14, 18), 16)) >>> 8;\n  arr[7] = v & 0xff;\n\n  // Block 4\n  arr[8] = (v = parseInt(uuid.slice(19, 23), 16)) >>> 8;\n  arr[9] = v & 0xff;\n\n  // Block 5\n  arr[10] = ((v = parseInt(uuid.slice(24, 36), 16)) / 0x10000000000) & 0xff;\n  arr[11] = (v / 0x100000000) & 0xff;\n  arr[12] = (v >>> 24) & 0xff;\n  arr[13] = (v >>> 16) & 0xff;\n  arr[14] = (v >>> 8) & 0xff;\n  arr[15] = v & 0xff;\n\n  return arr;\n}\n","/* eslint-disable no-bitwise */\nconst alphabet: string = \"0123456789abcdefghjkmnpqrstvwxyz\";\n\n// Decoding table\nconst dec: Uint8Array = new Uint8Array([\n  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x01, 0x02, 0x03,\n  0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f, 0x10,\n  0x11, 0xff, 0x12, 0x13, 0xff, 0x14, 0x15, 0xff, 0x16, 0x17, 0x18, 0x19, 0x1a,\n  0xff, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n]);\n\nexport function encode(src: Uint8Array): string {\n  const dst: string[] = new Array(26).fill(\"\");\n\n  if (src.length !== 16) {\n    throw new Error(\n      `Invalid length. Expected 16 bytes, got ${src.length}. Input: ${src}`\n    );\n  }\n\n  // 10 byte timestamp\n  dst[0] = alphabet[(src[0] & 224) >> 5];\n  dst[1] = alphabet[src[0] & 31];\n  dst[2] = alphabet[(src[1] & 248) >> 3];\n  dst[3] = alphabet[((src[1] & 7) << 2) | ((src[2] & 192) >> 6)];\n  dst[4] = alphabet[(src[2] & 62) >> 1];\n  dst[5] = alphabet[((src[2] & 1) << 4) | ((src[3] & 240) >> 4)];\n  dst[6] = alphabet[((src[3] & 15) << 1) | ((src[4] & 128) >> 7)];\n  dst[7] = alphabet[(src[4] & 124) >> 2];\n  dst[8] = alphabet[((src[4] & 3) << 3) | ((src[5] & 224) >> 5)];\n  dst[9] = alphabet[src[5] & 31];\n\n  // 16 bytes of randomness\n  dst[10] = alphabet[(src[6] & 248) >> 3];\n  dst[11] = alphabet[((src[6] & 7) << 2) | ((src[7] & 192) >> 6)];\n  dst[12] = alphabet[(src[7] & 62) >> 1];\n  dst[13] = alphabet[((src[7] & 1) << 4) | ((src[8] & 240) >> 4)];\n  dst[14] = alphabet[((src[8] & 15) << 1) | ((src[9] & 128) >> 7)];\n  dst[15] = alphabet[(src[9] & 124) >> 2];\n  dst[16] = alphabet[((src[9] & 3) << 3) | ((src[10] & 224) >> 5)];\n  dst[17] = alphabet[src[10] & 31];\n  dst[18] = alphabet[(src[11] & 248) >> 3];\n  dst[19] = alphabet[((src[11] & 7) << 2) | ((src[12] & 192) >> 6)];\n  dst[20] = alphabet[(src[12] & 62) >> 1];\n  dst[21] = alphabet[((src[12] & 1) << 4) | ((src[13] & 240) >> 4)];\n  dst[22] = alphabet[((src[13] & 15) << 1) | ((src[14] & 128) >> 7)];\n  dst[23] = alphabet[(src[14] & 124) >> 2];\n  dst[24] = alphabet[((src[14] & 3) << 3) | ((src[15] & 224) >> 5)];\n  dst[25] = alphabet[src[15] & 31];\n\n  return dst.join(\"\");\n}\n\nexport function decode(s: string): Uint8Array {\n  if (s.length !== 26) {\n    throw new Error(\n      `Invalid length. Expected 26 bytes, got ${s.length}. Input: ${s}`\n    );\n  }\n\n  const encoder = new TextEncoder();\n  const v: Uint8Array = encoder.encode(s);\n\n  // Check if all the characters are part of the expected base32 character set.\n  if (\n    dec[v[0]] === 0xff ||\n    dec[v[1]] === 0xff ||\n    dec[v[2]] === 0xff ||\n    dec[v[3]] === 0xff ||\n    dec[v[4]] === 0xff ||\n    dec[v[5]] === 0xff ||\n    dec[v[6]] === 0xff ||\n    dec[v[7]] === 0xff ||\n    dec[v[8]] === 0xff ||\n    dec[v[9]] === 0xff ||\n    dec[v[10]] === 0xff ||\n    dec[v[11]] === 0xff ||\n    dec[v[12]] === 0xff ||\n    dec[v[13]] === 0xff ||\n    dec[v[14]] === 0xff ||\n    dec[v[15]] === 0xff ||\n    dec[v[16]] === 0xff ||\n    dec[v[17]] === 0xff ||\n    dec[v[18]] === 0xff ||\n    dec[v[19]] === 0xff ||\n    dec[v[20]] === 0xff ||\n    dec[v[21]] === 0xff ||\n    dec[v[22]] === 0xff ||\n    dec[v[23]] === 0xff ||\n    dec[v[24]] === 0xff ||\n    dec[v[25]] === 0xff\n  ) {\n    throw new Error(\"Invalid base32 character\");\n  }\n\n  const id = new Uint8Array(16);\n\n  // 6 bytes timestamp (48 bits)\n  id[0] = (dec[v[0]] << 5) | dec[v[1]];\n  id[1] = (dec[v[2]] << 3) | (dec[v[3]] >> 2);\n  id[2] = ((dec[v[3]] & 3) << 6) | (dec[v[4]] << 1) | (dec[v[5]] >> 4);\n  id[3] = ((dec[v[5]] & 15) << 4) | (dec[v[6]] >> 1);\n  id[4] = ((dec[v[6]] & 1) << 7) | (dec[v[7]] << 2) | (dec[v[8]] >> 3);\n  id[5] = ((dec[v[8]] & 7) << 5) | dec[v[9]];\n\n  // 10 bytes of entropy (80 bits)\n  id[6] = (dec[v[10]] << 3) | (dec[v[11]] >> 2);\n  id[7] = ((dec[v[11]] & 3) << 6) | (dec[v[12]] << 1) | (dec[v[13]] >> 4);\n  id[8] = ((dec[v[13]] & 15) << 4) | (dec[v[14]] >> 1);\n  id[9] = ((dec[v[14]] & 1) << 7) | (dec[v[15]] << 2) | (dec[v[16]] >> 3);\n  id[10] = ((dec[v[16]] & 7) << 5) | dec[v[17]];\n  id[11] = (dec[v[18]] << 3) | (dec[v[19]] >> 2);\n  id[12] = ((dec[v[19]] & 3) << 6) | (dec[v[20]] << 1) | (dec[v[21]] >> 4);\n  id[13] = ((dec[v[21]] & 15) << 4) | (dec[v[22]] >> 1);\n  id[14] = ((dec[v[22]] & 1) << 7) | (dec[v[23]] << 2) | (dec[v[24]] >> 3);\n  id[15] = ((dec[v[24]] & 7) << 5) | dec[v[25]];\n\n  return id;\n}\n","export function isValidPrefix(str: string): boolean {\n  if (str.length > 63) {\n    return false;\n  }\n\n  let code;\n  let i;\n  let len;\n\n  for (i = 0, len = str.length; i < len; i += 1) {\n    code = str.charCodeAt(i);\n    const isLowerAtoZ = code > 96 && code < 123;\n    const isUnderscore = code === 95;\n\n    // first and last char of prefix can only be [a-z]\n    if ((i === 0 || i === len - 1) && !isLowerAtoZ) {\n      return false;\n    }\n\n    if (!(isLowerAtoZ || isUnderscore)) {\n      return false;\n    }\n  }\n  return true;\n}\n","import { uuidv7obj, UUID } from \"uuidv7\";\nimport { parseUUID } from \"../parse_uuid\";\nimport { encode, decode } from \"../base32\";\nimport { isValidPrefix } from \"../prefix\";\n\nexport type TypeId<T> = string & { __type: T };\n\nexport function typeidUnboxed<T extends string>(\n  prefix: T = \"\" as T,\n  suffix: string = \"\"\n): TypeId<T> {\n  if (!isValidPrefix(prefix)) {\n    throw new Error(\"Invalid prefix. Must be at most 63 ascii letters [a-z_]\");\n  }\n\n  let finalSuffix: string;\n  if (suffix) {\n    finalSuffix = suffix;\n  } else {\n    const uuid = uuidv7obj();\n    finalSuffix = encode(uuid.bytes);\n  }\n\n  if (finalSuffix.length !== 26) {\n    throw new Error(\n      `Invalid length. Suffix should have 26 characters, got ${finalSuffix.length}`\n    );\n  }\n\n  if (finalSuffix[0] > \"7\") {\n    throw new Error(\n      \"Invalid suffix. First character must be in the range [0-7]\"\n    );\n  }\n\n  // Validate the suffix by decoding it. If it's invalid, an error will be thrown.\n  decode(finalSuffix);\n\n  if (prefix === \"\") {\n    return finalSuffix as TypeId<T>;\n  } else {\n    return `${prefix}_${finalSuffix}` as TypeId<T>;\n  }\n}\n\n/**\n * Constructs a TypeId from a string representation, optionally validating against a provided prefix.\n * This function splits the input `typeId` string by an underscore `_` to separate the prefix and suffix.\n * If the `typeId` contains no underscore, it is assumed to be a suffix with an empty prefix.\n * If a `prefix` is provided, it must match the prefix part of the `typeId`, or an error is thrown.\n *\n * @param {string} typeId - The string representation of the TypeId to be parsed.\n * @param {T} [prefix] - An optional prefix to validate against the prefix in the `typeId`.\n * @returns {TypeId<T>} A new TypeId instance constructed from the parsed `typeId`.\n * @throws {Error} If the `typeId` format is invalid, the prefix is empty when there's a separator,\n *                 or there's a prefix mismatch when a `prefix` is provided.\n * @template T - A string literal type that extends string.\n */\nexport function fromString<T extends string>(\n  typeId: string,\n  prefix?: T\n): TypeId<T> {\n  let p;\n  let s;\n\n  const underscoreIndex = typeId.lastIndexOf(\"_\");\n  if (underscoreIndex === -1) {\n    p = \"\" as T;\n    s = typeId;\n  } else {\n    p = typeId.substring(0, underscoreIndex) as T;\n    s = typeId.substring(underscoreIndex + 1);\n\n    if (!p) {\n      throw new Error(\n        `Invalid TypeId. Prefix cannot be empty when there's a separator: ${typeId}`\n      );\n    }\n  }\n\n  if (!s) {\n    throw new Error(`Invalid TypeId. Suffix cannot be empty`);\n  }\n\n  if (prefix && p !== prefix) {\n    throw new Error(\n      `Invalid TypeId. Prefix mismatch. Expected ${prefix}, got ${p}`\n    );\n  }\n\n  return typeidUnboxed(p, s);\n}\n\n/**\n * Parses a TypeId string into its prefix and suffix components.\n *\n * @param {TypeId<T>} typeId - The TypeId string to parse.\n * @returns {{ prefix: T; suffix: string }} An object containing the prefix and suffix of the TypeId.\n * @throws {Error} If the TypeId format is invalid (not exactly two parts separated by an underscore).\n *\n * @example\n * // For a valid TypeId 'example_00041061050r3gg28a1c60t3gf'\n * const { prefix, suffix } = parseTypeId('example_00041061050r3gg28a1c60t3gf');\n * console.log(prefix); // 'example'\n * console.log(suffix); // '00041061050r3gg28a1c60t3gf'\n *\n * @example\n * // Throws an error for invalid TypeId format\n * try {\n *   parseTypeId('invalidTypeId');\n * } catch (error) {\n *   console.error(error.message); // 'Invalid TypeId format: invalidTypeId'\n * }\n */\nexport function parseTypeId<T extends string>(\n  typeId: TypeId<T>\n): { prefix: T; suffix: string } {\n  return { prefix: getType(typeId), suffix: getSuffix(typeId) };\n}\n\n/**\n * Retrieves the prefix from a TypeId.\n *\n * @param {TypeId<T>} typeId - The TypeId from which to extract the prefix.\n * @returns {T} The prefix of the TypeId.\n */\nexport function getType<T extends string>(typeId: TypeId<T>): T {\n  const underscoreIndex = typeId.lastIndexOf(\"_\");\n  if (underscoreIndex === -1) {\n    return \"\" as T;\n  }\n  return typeId.substring(0, underscoreIndex) as T;\n}\n\n/**\n * Retrieves the suffix from a TypeId.\n *\n * @param {TypeId<T>} typeId - The TypeId from which to extract the suffix.\n * @returns {string} The suffix of the TypeId.\n */\nexport function getSuffix<T extends string>(typeId: TypeId<T>): string {\n  const underscoreIndex = typeId.lastIndexOf(\"_\");\n  if (underscoreIndex === -1) {\n    return typeId;\n  }\n  return typeId.substring(underscoreIndex + 1);\n}\n\nexport function toUUIDBytes<T extends string>(typeId: TypeId<T>): Uint8Array {\n  return decode(getSuffix(typeId));\n}\n\nexport function toUUID<T extends string>(typeId: TypeId<T>) {\n  const uuidBytes = toUUIDBytes(typeId);\n  const uuid = UUID.ofInner(uuidBytes);\n  return uuid.toString();\n}\n\nexport function fromUUIDBytes(\n  prefix: string,\n  bytes: Uint8Array\n): TypeId<typeof prefix> {\n  const suffix = encode(bytes);\n  return prefix\n    ? (`${prefix}_${suffix}` as TypeId<typeof prefix>)\n    : (suffix as TypeId<typeof prefix>);\n}\n\nexport function fromUUID<T extends string>(\n  uuid: string,\n  prefix?: T\n): TypeId<T> {\n  const suffix = encode(parseUUID(uuid));\n  return prefix ? (`${prefix}_${suffix}` as TypeId<T>) : (suffix as TypeId<T>);\n}\n","import { UUID } from \"uuidv7\";\nimport { parseUUID } from \"./parse_uuid\";\nimport { encode, decode } from \"./base32\";\nimport {\n  typeidUnboxed,\n  getSuffix,\n  getType,\n  fromString,\n} from \"./unboxed/typeid\";\n\nexport class TypeID<const T extends string> {\n  constructor(private prefix: T, private suffix: string = \"\") {\n    const typeIdRaw = typeidUnboxed(prefix, suffix);\n\n    this.prefix = getType(typeIdRaw);\n    this.suffix = getSuffix(typeIdRaw);\n  }\n\n  public getType(): T {\n    return this.prefix;\n  }\n\n  public getSuffix(): string {\n    return this.suffix;\n  }\n\n  public asType<const U extends string>(prefix: U): TypeID<U> {\n    const self = this as unknown as TypeID<U>;\n    if (self.prefix !== prefix) {\n      throw new Error(\n        `Cannot convert TypeID of type ${self.prefix} to type ${prefix}`\n      );\n    }\n    return self;\n  }\n\n  public toUUIDBytes(): Uint8Array {\n    return decode(this.suffix);\n  }\n\n  public toUUID(): string {\n    const uuid = UUID.ofInner(this.toUUIDBytes());\n    return uuid.toString();\n  }\n\n  public toString(): `${T}_${string}` | string {\n    if (this.prefix === \"\") {\n      return this.suffix;\n    }\n    return `${this.prefix}_${this.suffix}`;\n  }\n\n  static fromString<const T extends string>(\n    str: string,\n    prefix?: T\n  ): TypeID<T> {\n    const typeIdRaw = fromString(str, prefix);\n\n    return new TypeID<T>(getType(typeIdRaw) as T, getSuffix(typeIdRaw));\n  }\n\n  static fromUUIDBytes<const T extends string>(\n    prefix: T,\n    bytes: Uint8Array\n  ): TypeID<T> {\n    const suffix = encode(bytes);\n    return new TypeID(prefix, suffix);\n  }\n\n  static fromUUID<const T extends string>(prefix: T, uuid: string): TypeID<T> {\n    const suffix = encode(parseUUID(uuid));\n    return new TypeID(prefix, suffix);\n  }\n}\n\nexport function typeid<T extends string>(): TypeID<\"\">;\nexport function typeid<T extends string>(prefix: T): TypeID<T>;\nexport function typeid<T extends string>(prefix: T, suffix: string): TypeID<T>;\nexport function typeid<T extends string>(\n  prefix: T = \"\" as T,\n  suffix: string = \"\"\n): TypeID<T> {\n  return new TypeID(prefix, suffix);\n}\n"],"mappings":"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AA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EACxE;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EACxE;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EACxE;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EACxE;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EACxE;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EACxE;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EACxE;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EACxE;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EACxE;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAA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","names":[]}
\ No newline at end of file
+{"version":3,"sources":["../node_modules/.pnpm/uuid@10.0.0/node_modules/uuid/dist/esm-node/regex.js","../node_modules/.pnpm/uuid@10.0.0/node_modules/uuid/dist/esm-node/validate.js","../node_modules/.pnpm/uuid@10.0.0/node_modules/uuid/dist/esm-node/stringify.js","../node_modules/.pnpm/uuid@10.0.0/node_modules/uuid/dist/esm-node/rng.js","../node_modules/.pnpm/uuid@10.0.0/node_modules/uuid/dist/esm-node/v7.js","../src/parse_uuid.ts","../src/base32.ts","../src/prefix.ts","../src/unboxed/typeid.ts","../src/typeid.ts"],"sourcesContent":["export default /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-8][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000|ffffffff-ffff-ffff-ffff-ffffffffffff)$/i;","import REGEX from './regex.js';\nfunction validate(uuid) {\n  return typeof uuid === 'string' && REGEX.test(uuid);\n}\nexport default validate;","import validate from './validate.js';\n\n/**\n * Convert array of 16 byte values to UUID string format of the form:\n * XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX\n */\nconst byteToHex = [];\nfor (let i = 0; i < 256; ++i) {\n  byteToHex.push((i + 0x100).toString(16).slice(1));\n}\nexport function unsafeStringify(arr, offset = 0) {\n  // Note: Be careful editing this code!  It's been tuned for performance\n  // and works in ways you may not expect. See https://github.com/uuidjs/uuid/pull/434\n  //\n  // Note to future-self: No, you can't remove the `toLowerCase()` call.\n  // REF: https://github.com/uuidjs/uuid/pull/677#issuecomment-1757351351\n  return (byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + '-' + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + '-' + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + '-' + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + '-' + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]]).toLowerCase();\n}\nfunction stringify(arr, offset = 0) {\n  const uuid = unsafeStringify(arr, offset);\n  // Consistency check for valid UUID.  If this throws, it's likely due to one\n  // of the following:\n  // - One or more input array values don't map to a hex octet (leading to\n  // \"undefined\" in the uuid)\n  // - Invalid input values for the RFC `version` or `variant` fields\n  if (!validate(uuid)) {\n    throw TypeError('Stringified UUID is invalid');\n  }\n  return uuid;\n}\nexport default stringify;","import crypto from 'node:crypto';\nconst rnds8Pool = new Uint8Array(256); // # of random values to pre-allocate\nlet poolPtr = rnds8Pool.length;\nexport default function rng() {\n  if (poolPtr > rnds8Pool.length - 16) {\n    crypto.randomFillSync(rnds8Pool);\n    poolPtr = 0;\n  }\n  return rnds8Pool.slice(poolPtr, poolPtr += 16);\n}","import rng from './rng.js';\nimport { unsafeStringify } from './stringify.js';\n\n/**\n * UUID V7 - Unix Epoch time-based UUID\n *\n * The IETF has published RFC9562, introducing 3 new UUID versions (6,7,8). This\n * implementation of V7 is based on the accepted, though not yet approved,\n * revisions.\n *\n * RFC 9562:https://www.rfc-editor.org/rfc/rfc9562.html Universally Unique\n * IDentifiers (UUIDs)\n\n *\n * Sample V7 value:\n * https://www.rfc-editor.org/rfc/rfc9562.html#name-example-of-a-uuidv7-value\n *\n * Monotonic Bit Layout: RFC rfc9562.6.2 Method 1, Dedicated Counter Bits ref:\n *     https://www.rfc-editor.org/rfc/rfc9562.html#section-6.2-5.1\n *\n *   0                   1                   2                   3 0 1 2 3 4 5 6\n *   7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n *  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n *  |                          unix_ts_ms                           |\n *  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n *  |          unix_ts_ms           |  ver  |        seq_hi         |\n *  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n *  |var|               seq_low               |        rand         |\n *  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n *  |                             rand                              |\n *  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n *\n * seq is a 31 bit serialized counter; comprised of 12 bit seq_hi and 19 bit\n * seq_low, and randomly initialized upon timestamp change. 31 bit counter size\n * was selected as any bitwise operations in node are done as _signed_ 32 bit\n * ints. we exclude the sign bit.\n */\n\nlet _seqLow = null;\nlet _seqHigh = null;\nlet _msecs = 0;\nfunction v7(options, buf, offset) {\n  options = options || {};\n\n  // initialize buffer and pointer\n  let i = buf && offset || 0;\n  const b = buf || new Uint8Array(16);\n\n  // rnds is Uint8Array(16) filled with random bytes\n  const rnds = options.random || (options.rng || rng)();\n\n  // milliseconds since unix epoch, 1970-01-01 00:00\n  const msecs = options.msecs !== undefined ? options.msecs : Date.now();\n\n  // seq is user provided 31 bit counter\n  let seq = options.seq !== undefined ? options.seq : null;\n\n  // initialize local seq high/low parts\n  let seqHigh = _seqHigh;\n  let seqLow = _seqLow;\n\n  // check if clock has advanced and user has not provided msecs\n  if (msecs > _msecs && options.msecs === undefined) {\n    _msecs = msecs;\n\n    // unless user provided seq, reset seq parts\n    if (seq !== null) {\n      seqHigh = null;\n      seqLow = null;\n    }\n  }\n\n  // if we have a user provided seq\n  if (seq !== null) {\n    // trim provided seq to 31 bits of value, avoiding overflow\n    if (seq > 0x7fffffff) {\n      seq = 0x7fffffff;\n    }\n\n    // split provided seq into high/low parts\n    seqHigh = seq >>> 19 & 0xfff;\n    seqLow = seq & 0x7ffff;\n  }\n\n  // randomly initialize seq\n  if (seqHigh === null || seqLow === null) {\n    seqHigh = rnds[6] & 0x7f;\n    seqHigh = seqHigh << 8 | rnds[7];\n    seqLow = rnds[8] & 0x3f; // pad for var\n    seqLow = seqLow << 8 | rnds[9];\n    seqLow = seqLow << 5 | rnds[10] >>> 3;\n  }\n\n  // increment seq if within msecs window\n  if (msecs + 10000 > _msecs && seq === null) {\n    if (++seqLow > 0x7ffff) {\n      seqLow = 0;\n      if (++seqHigh > 0xfff) {\n        seqHigh = 0;\n\n        // increment internal _msecs. this allows us to continue incrementing\n        // while staying monotonic. Note, once we hit 10k milliseconds beyond system\n        // clock, we will reset breaking monotonicity (after (2^31)*10000 generations)\n        _msecs++;\n      }\n    }\n  } else {\n    // resetting; we have advanced more than\n    // 10k milliseconds beyond system clock\n    _msecs = msecs;\n  }\n  _seqHigh = seqHigh;\n  _seqLow = seqLow;\n\n  // [bytes 0-5] 48 bits of local timestamp\n  b[i++] = _msecs / 0x10000000000 & 0xff;\n  b[i++] = _msecs / 0x100000000 & 0xff;\n  b[i++] = _msecs / 0x1000000 & 0xff;\n  b[i++] = _msecs / 0x10000 & 0xff;\n  b[i++] = _msecs / 0x100 & 0xff;\n  b[i++] = _msecs & 0xff;\n\n  // [byte 6] - set 4 bits of version (7) with first 4 bits seq_hi\n  b[i++] = seqHigh >>> 4 & 0x0f | 0x70;\n\n  // [byte 7] remaining 8 bits of seq_hi\n  b[i++] = seqHigh & 0xff;\n\n  // [byte 8] - variant (2 bits), first 6 bits seq_low\n  b[i++] = seqLow >>> 13 & 0x3f | 0x80;\n\n  // [byte 9] 8 bits seq_low\n  b[i++] = seqLow >>> 5 & 0xff;\n\n  // [byte 10] remaining 5 bits seq_low, 3 bits random\n  b[i++] = seqLow << 3 & 0xff | rnds[10] & 0x07;\n\n  // [bytes 11-15] always random\n  b[i++] = rnds[11];\n  b[i++] = rnds[12];\n  b[i++] = rnds[13];\n  b[i++] = rnds[14];\n  b[i++] = rnds[15];\n  return buf || unsafeStringify(b);\n}\nexport default v7;","/* eslint-disable no-bitwise */\nexport function parseUUID(uuid: string) {\n  let v;\n  const arr = new Uint8Array(16);\n\n  // Block 1\n  arr[0] = (v = parseInt(uuid.slice(0, 8), 16)) >>> 24;\n  arr[1] = (v >>> 16) & 0xff;\n  arr[2] = (v >>> 8) & 0xff;\n  arr[3] = v & 0xff;\n\n  // Block 2\n  arr[4] = (v = parseInt(uuid.slice(9, 13), 16)) >>> 8;\n  arr[5] = v & 0xff;\n\n  // Block 3\n  arr[6] = (v = parseInt(uuid.slice(14, 18), 16)) >>> 8;\n  arr[7] = v & 0xff;\n\n  // Block 4\n  arr[8] = (v = parseInt(uuid.slice(19, 23), 16)) >>> 8;\n  arr[9] = v & 0xff;\n\n  // Block 5\n  arr[10] = ((v = parseInt(uuid.slice(24, 36), 16)) / 0x10000000000) & 0xff;\n  arr[11] = (v / 0x100000000) & 0xff;\n  arr[12] = (v >>> 24) & 0xff;\n  arr[13] = (v >>> 16) & 0xff;\n  arr[14] = (v >>> 8) & 0xff;\n  arr[15] = v & 0xff;\n\n  return arr;\n}\n","/* eslint-disable no-bitwise */\nconst alphabet: string = \"0123456789abcdefghjkmnpqrstvwxyz\";\n\n// Decoding table\nconst dec: Uint8Array = new Uint8Array([\n  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x01, 0x02, 0x03,\n  0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f, 0x10,\n  0x11, 0xff, 0x12, 0x13, 0xff, 0x14, 0x15, 0xff, 0x16, 0x17, 0x18, 0x19, 0x1a,\n  0xff, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n]);\n\nexport function encode(src: Uint8Array): string {\n  const dst: string[] = new Array(26).fill(\"\");\n\n  if (src.length !== 16) {\n    throw new Error(\n      `Invalid length. Expected 16 bytes, got ${src.length}. Input: ${src}`\n    );\n  }\n\n  // 10 byte timestamp\n  dst[0] = alphabet[(src[0] & 224) >> 5];\n  dst[1] = alphabet[src[0] & 31];\n  dst[2] = alphabet[(src[1] & 248) >> 3];\n  dst[3] = alphabet[((src[1] & 7) << 2) | ((src[2] & 192) >> 6)];\n  dst[4] = alphabet[(src[2] & 62) >> 1];\n  dst[5] = alphabet[((src[2] & 1) << 4) | ((src[3] & 240) >> 4)];\n  dst[6] = alphabet[((src[3] & 15) << 1) | ((src[4] & 128) >> 7)];\n  dst[7] = alphabet[(src[4] & 124) >> 2];\n  dst[8] = alphabet[((src[4] & 3) << 3) | ((src[5] & 224) >> 5)];\n  dst[9] = alphabet[src[5] & 31];\n\n  // 16 bytes of randomness\n  dst[10] = alphabet[(src[6] & 248) >> 3];\n  dst[11] = alphabet[((src[6] & 7) << 2) | ((src[7] & 192) >> 6)];\n  dst[12] = alphabet[(src[7] & 62) >> 1];\n  dst[13] = alphabet[((src[7] & 1) << 4) | ((src[8] & 240) >> 4)];\n  dst[14] = alphabet[((src[8] & 15) << 1) | ((src[9] & 128) >> 7)];\n  dst[15] = alphabet[(src[9] & 124) >> 2];\n  dst[16] = alphabet[((src[9] & 3) << 3) | ((src[10] & 224) >> 5)];\n  dst[17] = alphabet[src[10] & 31];\n  dst[18] = alphabet[(src[11] & 248) >> 3];\n  dst[19] = alphabet[((src[11] & 7) << 2) | ((src[12] & 192) >> 6)];\n  dst[20] = alphabet[(src[12] & 62) >> 1];\n  dst[21] = alphabet[((src[12] & 1) << 4) | ((src[13] & 240) >> 4)];\n  dst[22] = alphabet[((src[13] & 15) << 1) | ((src[14] & 128) >> 7)];\n  dst[23] = alphabet[(src[14] & 124) >> 2];\n  dst[24] = alphabet[((src[14] & 3) << 3) | ((src[15] & 224) >> 5)];\n  dst[25] = alphabet[src[15] & 31];\n\n  return dst.join(\"\");\n}\n\nexport function decode(s: string): Uint8Array {\n  if (s.length !== 26) {\n    throw new Error(\n      `Invalid length. Expected 26 bytes, got ${s.length}. Input: ${s}`\n    );\n  }\n\n  const encoder = new TextEncoder();\n  const v: Uint8Array = encoder.encode(s);\n\n  // Check if all the characters are part of the expected base32 character set.\n  if (\n    dec[v[0]] === 0xff ||\n    dec[v[1]] === 0xff ||\n    dec[v[2]] === 0xff ||\n    dec[v[3]] === 0xff ||\n    dec[v[4]] === 0xff ||\n    dec[v[5]] === 0xff ||\n    dec[v[6]] === 0xff ||\n    dec[v[7]] === 0xff ||\n    dec[v[8]] === 0xff ||\n    dec[v[9]] === 0xff ||\n    dec[v[10]] === 0xff ||\n    dec[v[11]] === 0xff ||\n    dec[v[12]] === 0xff ||\n    dec[v[13]] === 0xff ||\n    dec[v[14]] === 0xff ||\n    dec[v[15]] === 0xff ||\n    dec[v[16]] === 0xff ||\n    dec[v[17]] === 0xff ||\n    dec[v[18]] === 0xff ||\n    dec[v[19]] === 0xff ||\n    dec[v[20]] === 0xff ||\n    dec[v[21]] === 0xff ||\n    dec[v[22]] === 0xff ||\n    dec[v[23]] === 0xff ||\n    dec[v[24]] === 0xff ||\n    dec[v[25]] === 0xff\n  ) {\n    throw new Error(\"Invalid base32 character\");\n  }\n\n  const id = new Uint8Array(16);\n\n  // 6 bytes timestamp (48 bits)\n  id[0] = (dec[v[0]] << 5) | dec[v[1]];\n  id[1] = (dec[v[2]] << 3) | (dec[v[3]] >> 2);\n  id[2] = ((dec[v[3]] & 3) << 6) | (dec[v[4]] << 1) | (dec[v[5]] >> 4);\n  id[3] = ((dec[v[5]] & 15) << 4) | (dec[v[6]] >> 1);\n  id[4] = ((dec[v[6]] & 1) << 7) | (dec[v[7]] << 2) | (dec[v[8]] >> 3);\n  id[5] = ((dec[v[8]] & 7) << 5) | dec[v[9]];\n\n  // 10 bytes of entropy (80 bits)\n  id[6] = (dec[v[10]] << 3) | (dec[v[11]] >> 2);\n  id[7] = ((dec[v[11]] & 3) << 6) | (dec[v[12]] << 1) | (dec[v[13]] >> 4);\n  id[8] = ((dec[v[13]] & 15) << 4) | (dec[v[14]] >> 1);\n  id[9] = ((dec[v[14]] & 1) << 7) | (dec[v[15]] << 2) | (dec[v[16]] >> 3);\n  id[10] = ((dec[v[16]] & 7) << 5) | dec[v[17]];\n  id[11] = (dec[v[18]] << 3) | (dec[v[19]] >> 2);\n  id[12] = ((dec[v[19]] & 3) << 6) | (dec[v[20]] << 1) | (dec[v[21]] >> 4);\n  id[13] = ((dec[v[21]] & 15) << 4) | (dec[v[22]] >> 1);\n  id[14] = ((dec[v[22]] & 1) << 7) | (dec[v[23]] << 2) | (dec[v[24]] >> 3);\n  id[15] = ((dec[v[24]] & 7) << 5) | dec[v[25]];\n\n  return id;\n}\n","export function isValidPrefix(str: string): boolean {\n  if (str.length > 63) {\n    return false;\n  }\n\n  let code;\n  let i;\n  let len;\n\n  for (i = 0, len = str.length; i < len; i += 1) {\n    code = str.charCodeAt(i);\n    const isLowerAtoZ = code > 96 && code < 123;\n    const isUnderscore = code === 95;\n\n    // first and last char of prefix can only be [a-z]\n    if ((i === 0 || i === len - 1) && !isLowerAtoZ) {\n      return false;\n    }\n\n    if (!(isLowerAtoZ || isUnderscore)) {\n      return false;\n    }\n  }\n  return true;\n}\n","import { stringify, v7 } from \"uuid\";\nimport { parseUUID } from \"../parse_uuid\";\nimport { encode, decode } from \"../base32\";\nimport { isValidPrefix } from \"../prefix\";\n\nexport type TypeId<T> = string & { __type: T };\n\nexport function typeidUnboxed<T extends string>(\n  prefix: T = \"\" as T,\n  suffix: string = \"\"\n): TypeId<T> {\n  if (!isValidPrefix(prefix)) {\n    throw new Error(\"Invalid prefix. Must be at most 63 ascii letters [a-z_]\");\n  }\n\n  let finalSuffix: string;\n  if (suffix) {\n    finalSuffix = suffix;\n  } else {\n    const buffer = new Uint8Array(16);\n    v7(undefined, buffer);\n    finalSuffix = encode(buffer);\n  }\n\n  if (finalSuffix.length !== 26) {\n    throw new Error(\n      `Invalid length. Suffix should have 26 characters, got ${finalSuffix.length}`\n    );\n  }\n\n  if (finalSuffix[0] > \"7\") {\n    throw new Error(\n      \"Invalid suffix. First character must be in the range [0-7]\"\n    );\n  }\n\n  // Validate the suffix by decoding it. If it's invalid, an error will be thrown.\n  decode(finalSuffix);\n\n  if (prefix === \"\") {\n    return finalSuffix as TypeId<T>;\n  } else {\n    return `${prefix}_${finalSuffix}` as TypeId<T>;\n  }\n}\n\n/**\n * Constructs a TypeId from a string representation, optionally validating against a provided prefix.\n * This function splits the input `typeId` string by an underscore `_` to separate the prefix and suffix.\n * If the `typeId` contains no underscore, it is assumed to be a suffix with an empty prefix.\n * If a `prefix` is provided, it must match the prefix part of the `typeId`, or an error is thrown.\n *\n * @param {string} typeId - The string representation of the TypeId to be parsed.\n * @param {T} [prefix] - An optional prefix to validate against the prefix in the `typeId`.\n * @returns {TypeId<T>} A new TypeId instance constructed from the parsed `typeId`.\n * @throws {Error} If the `typeId` format is invalid, the prefix is empty when there's a separator,\n *                 or there's a prefix mismatch when a `prefix` is provided.\n * @template T - A string literal type that extends string.\n */\nexport function fromString<T extends string>(\n  typeId: string,\n  prefix?: T\n): TypeId<T> {\n  let p;\n  let s;\n\n  const underscoreIndex = typeId.lastIndexOf(\"_\");\n  if (underscoreIndex === -1) {\n    p = \"\" as T;\n    s = typeId;\n  } else {\n    p = typeId.substring(0, underscoreIndex) as T;\n    s = typeId.substring(underscoreIndex + 1);\n\n    if (!p) {\n      throw new Error(\n        `Invalid TypeId. Prefix cannot be empty when there's a separator: ${typeId}`\n      );\n    }\n  }\n\n  if (!s) {\n    throw new Error(`Invalid TypeId. Suffix cannot be empty`);\n  }\n\n  if (prefix && p !== prefix) {\n    throw new Error(\n      `Invalid TypeId. Prefix mismatch. Expected ${prefix}, got ${p}`\n    );\n  }\n\n  return typeidUnboxed(p, s);\n}\n\n/**\n * Parses a TypeId string into its prefix and suffix components.\n *\n * @param {TypeId<T>} typeId - The TypeId string to parse.\n * @returns {{ prefix: T; suffix: string }} An object containing the prefix and suffix of the TypeId.\n * @throws {Error} If the TypeId format is invalid (not exactly two parts separated by an underscore).\n *\n * @example\n * // For a valid TypeId 'example_00041061050r3gg28a1c60t3gf'\n * const { prefix, suffix } = parseTypeId('example_00041061050r3gg28a1c60t3gf');\n * console.log(prefix); // 'example'\n * console.log(suffix); // '00041061050r3gg28a1c60t3gf'\n *\n * @example\n * // Throws an error for invalid TypeId format\n * try {\n *   parseTypeId('invalidTypeId');\n * } catch (error) {\n *   console.error(error.message); // 'Invalid TypeId format: invalidTypeId'\n * }\n */\nexport function parseTypeId<T extends string>(\n  typeId: TypeId<T>\n): { prefix: T; suffix: string } {\n  return { prefix: getType(typeId), suffix: getSuffix(typeId) };\n}\n\n/**\n * Retrieves the prefix from a TypeId.\n *\n * @param {TypeId<T>} typeId - The TypeId from which to extract the prefix.\n * @returns {T} The prefix of the TypeId.\n */\nexport function getType<T extends string>(typeId: TypeId<T>): T {\n  const underscoreIndex = typeId.lastIndexOf(\"_\");\n  if (underscoreIndex === -1) {\n    return \"\" as T;\n  }\n  return typeId.substring(0, underscoreIndex) as T;\n}\n\n/**\n * Retrieves the suffix from a TypeId.\n *\n * @param {TypeId<T>} typeId - The TypeId from which to extract the suffix.\n * @returns {string} The suffix of the TypeId.\n */\nexport function getSuffix<T extends string>(typeId: TypeId<T>): string {\n  const underscoreIndex = typeId.lastIndexOf(\"_\");\n  if (underscoreIndex === -1) {\n    return typeId;\n  }\n  return typeId.substring(underscoreIndex + 1);\n}\n\nexport function toUUIDBytes<T extends string>(typeId: TypeId<T>): Uint8Array {\n  return decode(getSuffix(typeId));\n}\n\nexport function toUUID<T extends string>(typeId: TypeId<T>) {\n  return stringify(toUUIDBytes(typeId));\n}\n\nexport function fromUUIDBytes(\n  prefix: string,\n  bytes: Uint8Array\n): TypeId<typeof prefix> {\n  const suffix = encode(bytes);\n  return prefix\n    ? (`${prefix}_${suffix}` as TypeId<typeof prefix>)\n    : (suffix as TypeId<typeof prefix>);\n}\n\nexport function fromUUID<T extends string>(\n  uuid: string,\n  prefix?: T\n): TypeId<T> {\n  const suffix = encode(parseUUID(uuid));\n  return prefix ? (`${prefix}_${suffix}` as TypeId<T>) : (suffix as TypeId<T>);\n}\n","import { stringify } from \"uuid\";\nimport { parseUUID } from \"./parse_uuid\";\nimport { encode, decode } from \"./base32\";\nimport {\n  typeidUnboxed,\n  getSuffix,\n  getType,\n  fromString,\n} from \"./unboxed/typeid\";\n\nexport class TypeID<const T extends string> {\n  constructor(private prefix: T, private suffix: string = \"\") {\n    const typeIdRaw = typeidUnboxed(prefix, suffix);\n\n    this.prefix = getType(typeIdRaw);\n    this.suffix = getSuffix(typeIdRaw);\n  }\n\n  public getType(): T {\n    return this.prefix;\n  }\n\n  public getSuffix(): string {\n    return this.suffix;\n  }\n\n  public asType<const U extends string>(prefix: U): TypeID<U> {\n    const self = this as unknown as TypeID<U>;\n    if (self.prefix !== prefix) {\n      throw new Error(\n        `Cannot convert TypeID of type ${self.prefix} to type ${prefix}`\n      );\n    }\n    return self;\n  }\n\n  public toUUIDBytes(): Uint8Array {\n    return decode(this.suffix);\n  }\n\n  public toUUID(): string {\n    return stringify(this.toUUIDBytes());\n  }\n\n  public toString(): `${T}_${string}` | string {\n    if (this.prefix === \"\") {\n      return this.suffix;\n    }\n    return `${this.prefix}_${this.suffix}`;\n  }\n\n  static fromString<const T extends string>(\n    str: string,\n    prefix?: T\n  ): TypeID<T> {\n    const typeIdRaw = fromString(str, prefix);\n\n    return new TypeID<T>(getType(typeIdRaw) as T, getSuffix(typeIdRaw));\n  }\n\n  static fromUUIDBytes<const T extends string>(\n    prefix: T,\n    bytes: Uint8Array\n  ): TypeID<T> {\n    const suffix = encode(bytes);\n    return new TypeID(prefix, suffix);\n  }\n\n  static fromUUID<const T extends string>(prefix: T, uuid: string): TypeID<T> {\n    const suffix = encode(parseUUID(uuid));\n    return new TypeID(prefix, suffix);\n  }\n}\n\nexport function typeid<T extends string>(): TypeID<\"\">;\nexport function typeid<T extends string>(prefix: T): TypeID<T>;\nexport function typeid<T extends string>(prefix: T, suffix: string): TypeID<T>;\nexport function typeid<T extends string>(\n  prefix: T = \"\" as T,\n  suffix: string = \"\"\n): TypeID<T> {\n  return new TypeID(prefix, suffix);\n}\n"],"mappings":"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,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EACxE;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EACxE;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EACxE;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EACxE;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EACxE;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EACxE;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EACxE;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EACxE;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EACxE;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EACxE;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EACxE;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EACxE;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EACxE;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EACxE;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EACxE;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EACxE;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EACxE;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EACxE;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAClD,CAAC;AAEM,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","names":[]}
\ No newline at end of file
